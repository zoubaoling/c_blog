import{_ as l,c as i,o as e,a5 as t}from"./chunks/framework.B102yH4G.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/ES6函数新增扩展.md","filePath":"ES6/ES6函数新增扩展.md","lastUpdated":1715864760000}'),n={name:"ES6/ES6函数新增扩展.md"},a=t('<h2 id="es6函数新增了哪些扩展" tabindex="-1">ES6函数新增了哪些扩展 <a class="header-anchor" href="#es6函数新增了哪些扩展" aria-label="Permalink to &quot;ES6函数新增了哪些扩展&quot;">​</a></h2><ol><li>参数默认值 <ul><li>参数可以设置默认值，参数不传或者传的值为undefined时使用默认值,如果传参为null,取值为null，不会使用默认值</li><li>参数设置默认值后，会影响arguments，和es5严格模式一样，形参和arguments分离，修改设置了默认值的参数值或arguments后，彼此不会相互影响</li><li>默认参数是在函数调用时求值，后定义的参数可以访问先定义的参数</li><li>函数参数和函数体的作用域是分开的，函数参数不可以访问函数体内的变量</li></ul></li><li>rest参数、不定参数，通过...获取，是一个数组 <ul><li>需要放在参数默认值后面</li><li>一个函数中只能有一个不定参数</li><li>对象字面量的set函数中不可以使用，因为只会有一个参数</li><li>不定参数可以用来替换arguments，但是arguments仍然可以使用</li></ul></li><li>展开运算符，将一个数组打散开成独立的参数传入函数</li><li>name属性，获取函数的名称 <ul><li>函数表达式名称权重最高<code>function funName</code> &gt; funName</li><li>赋值值其他变量，函数表达式有名称为其名称，没有则为变量名称</li><li>Function构造函数函数创建的为anonymous(匿名)</li><li>bind()函数创建的会带有<code>bound </code>前缀</li></ul></li><li>新增判断函数的用途：new.target,只能在函数内使用 <ul><li>函数可作为new构造函数或执行函数使用,原来可以通过this instanceof ContrucName判断（new会创建实例对象，并将this绑定到实例上）</li><li>新增new.target属性，如果普通执行,new.target为undefined，如果通过new执行,返回实例对象也就是构造函数，但是都可能会被call apply bind影响</li></ul></li><li>块级函数，<code>function</code>声明会被提升到作用域顶部，如果使用let声明，不会提升</li><li>箭头函数 <ul><li>没有arguments，可以使用rest参数代替</li><li>this是定义时决定，不是使用时决定，为外部最近一层非箭头函数的this，否则是全局对象</li><li>不能作为构造函数，不能使用new命令</li><li>没有原型</li><li>不能改变this指向</li></ul></li></ol>',2),s=[a];function o(r,u,c,_,d,m){return e(),i("div",null,s)}const p=l(n,[["render",o]]);export{h as __pageData,p as default};
