import{_ as e,c as t,o as a,a5 as i}from"./chunks/framework.B102yH4G.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/事件循环.md","filePath":"js/事件循环.md","lastUpdated":1715864760000}'),l={name:"js/事件循环.md"},s=i('<h2 id="说说对事件循环的理解" tabindex="-1">说说对事件循环的理解 <a class="header-anchor" href="#说说对事件循环的理解" aria-label="Permalink to &quot;说说对事件循环的理解&quot;">​</a></h2><p>JS是一个单线程的脚本语言，同一时间只能做一件事。事件循环可以实现单线程非阻塞,确保JS程序能够处理大量的异步任务并保持程序的响应性</p><p>JS任务：</p><ul><li>同步任务：立刻执行的任务，一般会直接进入主线程执行</li><li>异步任务：异步执行的任务，比如接口请求，定时器等，会进入任务队列。</li></ul><p><em>主线程 执行栈 任务队列 宏任务 微任务</em></p><p><strong>定义</strong>:主线程里的同步任务执行完毕，会去任务队列读取任务，有任务就推入到主线程执行，如果执行宏任务之前有微任务，那么先执行微任务，这样的过程不断重复就是事件循环，直到所有任务执行完毕</p><h3 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h3><p>异步任务分为宏任务和微任务，微任务在宏任务之前执行</p><p><strong>微任务</strong></p><ul><li>Promise.then</li><li>MutationObserver</li><li>Object.observe Proxy</li><li>process.nextTick(Node.js)</li></ul><p>await是返回一个Promise对象，所以await下面的代码会加入微任务队列</p><p><strong>宏任务</strong></p><p>时间粒度较大，执行时间间隔不能精确控制，高实时性需求不太符合</p><ul><li>script 外层同步代码</li><li>setTimeout/setInterval</li><li>UI rendering</li><li>postMessage MessageChannel</li><li>setImmediate I/O (Node.js)</li></ul><h3 id="顺序" tabindex="-1">顺序 <a class="header-anchor" href="#顺序" aria-label="Permalink to &quot;顺序&quot;">​</a></h3><ul><li>执行一个宏任务，如果遇到微任务会将其放到微任务的事件队列里</li><li>当前宏任务执行完，查看微任务的事件队列，里面所有微任务执行完然后执行下一个宏任务</li></ul>',16),r=[s];function o(n,p,_,c,d,h){return a(),t("div",null,r)}const f=e(l,[["render",o]]);export{m as __pageData,f as default};
