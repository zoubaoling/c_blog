import{_ as e,c as t,o as d,a3 as r}from"./chunks/framework.BmlUaO9n.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue生命周期.md","filePath":"vue/vue生命周期.md","lastUpdated":1715657339000}'),a={name:"vue/vue生命周期.md"},o=r('<h2 id="请描述下你对vue生命周期的理解-在created和mounted这两个生命周期中请求数据有什么区别呢" tabindex="-1">请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢 <a class="header-anchor" href="#请描述下你对vue生命周期的理解-在created和mounted这两个生命周期中请求数据有什么区别呢" aria-label="Permalink to &quot;请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢&quot;">​</a></h2><h3 id="基本api" tabindex="-1">基本API <a class="header-anchor" href="#基本api" aria-label="Permalink to &quot;基本API&quot;">​</a></h3><p>组合式API中：beforeCreate和created在setup中，直接写逻辑即可 vue3要用import导入，选项式写法是写在methods中</p><table><thead><tr><th>生命周期函数</th><th>描述</th><th>vue3</th></tr></thead><tbody><tr><td>beforeCreate</td><td>执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务(生命周期)，数据观测和事件等未初始化</td><td>setup</td></tr><tr><td>created</td><td>创建实例后调用，此时实例的数据观测、事件等已经初始化完成，各种数据可以使用，常用于异步数据获取 initState: props methods data computed watch</td><td>setup</td></tr><tr><td>beforeMount</td><td>挂载实例之前调用，此时模板已经编译完成，但是还未挂载到DOM</td><td>onBeforeMounted</td></tr><tr><td>mounted</td><td>挂载实例后调用，此时实例已经挂载到DOM，可以进行DOM操作</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>数据更新之前调用，可用于获取更新前各种状态</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>数据更新后调用，此时DOM已经完成更新，可以进行DOM操作</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>销毁前，可用于一些定时器或订阅的取消，实例仍然可用</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>组件已销毁，实例已经完全卸载</td><td>onUnmounted</td></tr><tr><td>以上为基本的生命周期，2 -&gt; 3的主要变化是 destroy -&gt; unmount, script setup的写法是在前面加上on</td><td></td><td></td></tr></tbody></table><h3 id="keep-alive生命周期" tabindex="-1">keep-alive生命周期 <a class="header-anchor" href="#keep-alive生命周期" aria-label="Permalink to &quot;keep-alive生命周期&quot;">​</a></h3><ul><li>activated | onActivated：keep-alive包裹的组件激活时调用</li><li>deactivated | onDeactivated：keep-alive包裹的组件停用时调用</li></ul><h3 id="errorcaptured-onerrorcaptured" tabindex="-1">errorCaptured | onErrorCaptured <a class="header-anchor" href="#errorcaptured-onerrorcaptured" aria-label="Permalink to &quot;errorCaptured | onErrorCaptured&quot;">​</a></h3><p>捕获来自子孙组件的错误</p><h3 id="onrendertracked-onrendertriggered" tabindex="-1">onRenderTracked onRenderTriggered <a class="header-anchor" href="#onrendertracked-onrendertriggered" aria-label="Permalink to &quot;onRenderTracked onRenderTriggered&quot;">​</a></h3><p>vue3新增的仅在开发模式下使用的钩子函数</p><ul><li>onRenderTracked: 组件渲染时追踪到响应式依赖时调用</li><li>onRenderTriggered: 响应式依赖变更触发了组件渲染时调用</li></ul><h3 id="父子组件生命周期顺序" tabindex="-1">父子组件生命周期顺序 <a class="header-anchor" href="#父子组件生命周期顺序" aria-label="Permalink to &quot;父子组件生命周期顺序&quot;">​</a></h3><p>父组件先初始化，执行到beforeMount,去活去父组件的虚拟DOM，然后进行patch patch过程中如果子组件是组件类型，那么就会进入子组件的初始化流程，走到beforeMount 如果存在子组件一样进入子组件初始化流程 如果不存在则当前子组件mounted完 父组件mounted完</p><blockquote><p>初始化、更新等过程中，父子组件是深度递归创建、更新子组件的过程</p></blockquote><ol><li>父组件 -&gt; beforeMount(beforeUpdate beforeUnmount)</li><li>子组件 -&gt; beforeMount(beforeUpdate beforeUnmount)</li><li>子组件 -&gt; mounted(updated unmmounted)</li><li>父组件 -&gt; mounted(updated unmounted)</li></ol><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ol><li>生命周期钩子函数中的this指向的是引用的实例，不可以用箭头函数</li><li>setup是唯一可以使用组合式钩子函数的地方，其他地方会运行时错误。但是可以写在其他地方，执行时上下文是setup即可</li></ol><h3 id="created-vs-mounted" tabindex="-1">created VS mounted <a class="header-anchor" href="#created-vs-mounted" aria-label="Permalink to &quot;created VS mounted&quot;">​</a></h3><ul><li>created组件实例创建完成，但是DOM未渲染；mounted DOM渲染完成，可以拿到DOM数据，都可以拿到属性和方法</li><li>在mounted时使用接口可能存在页面闪动问题，但是如果需要对接口请求完对DOM进行处理，可以在mounted中，否则使用created，不会存在闪动问题</li><li>请求数据与DOM无关，在created中，需要访问DOM，在mounted中</li></ul>',19),n=[o];function u(i,l,c,h,p,s){return d(),t("div",null,n)}const f=e(a,[["render",u]]);export{b as __pageData,f as default};
