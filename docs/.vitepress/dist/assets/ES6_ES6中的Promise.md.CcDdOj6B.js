import{_ as e,c as i,o as l,a3 as r}from"./chunks/framework.B7tteqv2.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/ES6中的Promise.md","filePath":"ES6/ES6中的Promise.md","lastUpdated":1714567771000}'),t={name:"ES6/ES6中的Promise.md"},o=r('<h2 id="你是怎么理解es6中-promise的-使用场景有哪些" tabindex="-1">你是怎么理解ES6中 Promise的？使用场景有哪些？ <a class="header-anchor" href="#你是怎么理解es6中-promise的-使用场景有哪些" aria-label="Permalink to &quot;你是怎么理解ES6中 Promise的？使用场景有哪些？&quot;">​</a></h2><p>promise是异步编程的一种解决方案，比传统的方式，比如回调函数更加强大、合理 解决了回调地狱的问题，相对来说：</p><ul><li>其链式操作降低了编码的难度</li><li>代码可读性和可维护性增强</li></ul><p>Promise有三种状态：pending fulfilled rejected 其状态一旦改变，不会发生变更</p><ul><li>pending &gt; fulfilled</li><li>pending &gt; rejected</li></ul><h3 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法&quot;">​</a></h3><p>Promise对象是一个构造函数，又来生成promise实例，接收两个参数resolve和reject</p><ul><li>resolve将状态由pending &gt; fulfilled</li><li>reject将状态由pending &gt; rejected</li></ul><p><strong>实例方法</strong></p><ul><li>then 状态变更时的回调，第一个参数resolve状态的回调函数，第二个参数是reject状态的回调函数。then返回一个新的Promise实例，所以可以链式调用</li><li>catch 指定发生错误时的回调 reject状态,promise的错误有冒泡性质，直到被捕获。promise的错误不会传递到外面，只能在内部捕获</li><li>finally 不管状态怎么样，最后都会执行的操作</li></ul><p><strong>构造函数方法</strong></p><ul><li>Promise.all: 接受一个Promise数组作为参数，数组所有元素都fulfilled,才会返回结果，一旦有一个reject，就会被捕获。如果实例内部有catch，会先被内部捕获</li><li>Promise.race: 接受多个Promise实例，最先改变状态的实例的结果和状态会先返回</li><li>Promise.allSettled：接受多个Promise实例，等所有实例都返回结果，才会返回 status reason value</li><li>Promise.resolve: 返回一个resolve状态的promise对象</li><li>Promise.reject：返回一个reject状态的promise对象</li></ul>',12),s=[o];function a(n,c,m,p,d,_){return l(),i("div",null,s)}const h=e(t,[["render",a]]);export{P as __pageData,h as default};
