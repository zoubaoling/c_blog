import{_ as i,c as t,o as l,a3 as e}from"./chunks/framework.COm4hYgr.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/this对象.md","filePath":"js/this对象.md","lastUpdated":1714650100000}'),s={name:"js/this对象.md"},a=e('<h2 id="谈谈this对象的理解" tabindex="-1">谈谈this对象的理解 <a class="header-anchor" href="#谈谈this对象的理解" aria-label="Permalink to &quot;谈谈this对象的理解&quot;">​</a></h2><p>大多数情况，函数的调用方式决定了this的值（运行时绑定） this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，指向调用它的对象</p><ol><li>全局对象中的this指向</li></ol><ul><li>指向的是window, 严格模式是undefined</li></ul><ol start="2"><li>全局作用域或者普通函数中的this</li></ol><ul><li>指向全局window，严格模式是undefined</li></ul><ol start="3"><li>作为对象的方法调用，this永远指向最后调用它的那个对象</li></ol><ul><li>在不是箭头函数的情况下</li></ul><ol start="4"><li>new 关键词改变了this的指向</li></ol><ul><li>构建函数返回了一个对象，this指向的是这个对象</li><li>否则，this指向的是实例对象</li></ul><ol start="5"><li>apply,call,bind</li></ol><ul><li>可以改变this指向，箭头函数不可修改</li></ul><ol start="6"><li>箭头函数中的this</li></ol><ul><li>箭头函数的this指向在定义的时候就已经确定了</li><li>箭头函数它没有this,看外层是否有普通函数，有就是外层函数的this，没有就是window</li></ul><ol start="7"><li>匿名函数中的this</li></ol><ul><li>永远指向了window,匿名函数的执行环境具有全局性，因此this指向window</li></ul><p>new &gt; call apply bind &gt; 其他</p><h3 id="addeventlistener" tabindex="-1">addEventListener <a class="header-anchor" href="#addeventlistener" aria-label="Permalink to &quot;addEventListener&quot;">​</a></h3><ol><li>使用非箭头函数绑定 <code>element.addEventListener(&#39;click&#39;, function() {})</code>: this绑定的是element，监听事件的元素</li><li>使用箭头函数 <code>element.addEventListener(&#39;click&#39;, () =&gt; {})</code>: this绑定的是window，箭头函数声明在全局作用域下，外部没有函数作用域</li></ol>',19),o=[a];function n(d,h,r,c,_,u){return l(),t("div",null,o)}const w=i(s,[["render",n]]);export{m as __pageData,w as default};
