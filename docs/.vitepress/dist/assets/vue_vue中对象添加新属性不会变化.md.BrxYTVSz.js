import{_ as e,c as a,o as t,a5 as l}from"./chunks/framework.B102yH4G.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue中对象添加新属性不会变化.md","filePath":"vue/vue中对象添加新属性不会变化.md","lastUpdated":1715938250000}'),o={name:"vue/vue中对象添加新属性不会变化.md"},i=l('<h2 id="动态给vue的data添加一个新的属性时会发生什么-怎样解决" tabindex="-1">动态给vue的data添加一个新的属性时会发生什么？怎样解决 <a class="header-anchor" href="#动态给vue的data添加一个新的属性时会发生什么-怎样解决" aria-label="Permalink to &quot;动态给vue的data添加一个新的属性时会发生什么？怎样解决&quot;">​</a></h2><h3 id="现象" tabindex="-1">现象 <a class="header-anchor" href="#现象" aria-label="Permalink to &quot;现象&quot;">​</a></h3><p>动态添加的属性数据会更新，但是视图不会更新</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><p>vue2在数据初始化的时候遍历对象所有的属性，通过Object.defineProperty对已有的属性进行拦截处理成响应式，后续动态添加的属性没有被拦截，不是响应式，所以视图不会被更新</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><ol><li><code>Vue.set | vm.$set (target, propertyName, value)</code><ul><li>给指定对象新增一个属性，新增的属性会进行响应式处理</li></ul></li><li><code>Object.assign</code><ul><li>将旧对象和新属性合并起来成一个新对象，赋给原对象，触发对象的getter</li></ul></li><li><code>$forceUpdate</code><ul><li>$forceUpdate重新渲染组件，只会影响实例本身和插入插槽内容的子组件，不是所有子组件</li></ul></li></ol><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ul><li>如果是添加少量的属性，可以采用set方法</li><li>如果要添加大量的新属性，可以使用Object.assign</li><li>不知道怎么办，可以使用$forceUpdate，但是一般此时就可以看看代码哪里是不是写的不合适了</li></ul>',9),r=[i];function d(c,s,_,u,n,h){return t(),a("div",null,r)}const m=e(o,[["render",d]]);export{f as __pageData,m as default};
