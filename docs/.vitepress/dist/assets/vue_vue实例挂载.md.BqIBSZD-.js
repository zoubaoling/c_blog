import{_ as e,c as t,o as a,a3 as l}from"./chunks/framework.COm4hYgr.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue实例挂载.md","filePath":"vue/vue实例挂载.md","lastUpdated":1714487493000}'),o={name:"vue/vue实例挂载.md"},i=l(`<h2 id="vue的实例挂载过程" tabindex="-1">vue的实例挂载过程 <a class="header-anchor" href="#vue的实例挂载过程" aria-label="Permalink to &quot;vue的实例挂载过程&quot;">​</a></h2><h3 id="new-vue的过程" tabindex="-1">new Vue的过程 <a class="header-anchor" href="#new-vue的过程" aria-label="Permalink to &quot;new Vue的过程&quot;">​</a></h3><ol><li>初始化生命周期、事件中心（初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件）、渲染</li><li>beforeCreate</li><li>初始化: injection &gt; state(props &gt; methods &gt; data &gt; computed &gt; watch) &gt; provide</li><li>created</li><li>$mount 挂载: 编译$mount &gt; 运行$mount（模版编译 〉模版挂载）</li></ol><h3 id="模版编译阶段" tabindex="-1">模版编译阶段 <a class="header-anchor" href="#模版编译阶段" aria-label="Permalink to &quot;模版编译阶段&quot;">​</a></h3><p>编译$mount: 将template中的原生HTML和非原生HTML内容找出来，经过一系列逻辑处理成渲染函数render，就是编译 template -&gt; 模版编译 -&gt; render -&gt; VNode -&gt; patch -&gt; 视图 模版编译：template -&gt; 模版编译 -&gt; render 虚拟DOM：VNode -&gt; patch -&gt; 视图</p><h4 id="模版编译" tabindex="-1">模版编译 <a class="header-anchor" href="#模版编译" aria-label="Permalink to &quot;模版编译&quot;">​</a></h4><ol><li>模版解析，将template解析生成AST语法树 parse parse: parseHTML -&gt; parseText parseFilters</li></ol><ul><li>文本</li><li>注释</li><li>DOCTYPE &lt;! DOCTYPE html&gt;</li><li>开始标签</li><li>结束标签 标签根据内容去匹配，使用正则匹配，匹配完创建AST节点。 文本解析是将parseHTML解析出来的文本内容进一步处理，文本中如果存在变量提取出来二次加工</li></ul><ol start="2"><li>优化阶段：遍历AST语法树，将静态节点打上标记 optimize 找出静态节点和静态根节点并打上标记 -〉 在patch阶段，静态节点就不需要比对 模版解析过程中会对节点判断添加type值</li><li>代码生成阶段：将AST语法树转换成渲染函数 generate 递归遍历根据tag data children生成对应的字符串<code>h(tag, data, children)</code>，再将对应字符串转换为可执行的方法</li></ol><h3 id="模版挂载阶段-运行-mount" tabindex="-1">模版挂载阶段 运行$mount <a class="header-anchor" href="#模版挂载阶段-运行-mount" aria-label="Permalink to &quot;模版挂载阶段 运行$mount&quot;">​</a></h3><p>vm.$mount：编译时 &gt; 运行时</p><blockquote><p>beforeMount &gt; 创建vm.$el并替换el &gt; mounted</p></blockquote><ol><li>vm.$mount方法--编译时</li><li>不能挂载到body和html中(document.body document.documentElement)</li><li>options.render存在，处理传入的template</li><li>处理template - 存在templaet,解析vue模版文件 <ul><li>如果是字符串类型且以#开头，作为ID获取元素</li><li>如果是节点，直接获取节点内容innerHTML</li><li>否则抛出警告，template不合法</li></ul></li></ol><pre><code>- 不存在template，根据el选择器获取template outerHTML
</code></pre><ol start="4"><li>编译解析template，得到render函数 - 将template解析成ast语法树ast tree - ast tree转换成render语法字符串 - render语法字符串转换成render方法</li><li>调用mount.call() -&gt; Vue.prototype.$mount(public mount method)方法--运行时</li><li>执行mountComponent</li><li>无render，生成空的虚拟节点</li><li>callHook: beforeMount(模版编译解析完成，但是未挂载)</li><li>定义updateComponent更新渲染视图的方法:vm._update(vm._render())-lifecycleMixin中定义的 - render: 生成虚拟节点VNode - update: <code>patch</code>节点,VNode转换为真实的DOM，并更新到页面</li><li>创建监听器<code>new Watcher(vm, updateComponent,...)</code>，开启对模版中数据的监控,组件数据变化执行updateComponent函数，并触发 <code>beforeUpdate</code>钩子函数 - updateComponent执行使用的数据会被getter拦截，将当前watcher实例添加到数据依赖列表中 - 数据变化时通知依赖列表里的依赖，依赖（watcher实例）接收到通知后，执行回调函数，更新视图，触发beforeUpdate</li></ol>`,15),r=[i];function n(d,u,p,c,m,s){return a(),t("div",null,r)}const g=e(o,[["render",n]]);export{_ as __pageData,g as default};
