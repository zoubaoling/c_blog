import{_ as t,c as l,o as e,a3 as i}from"./chunks/framework.BmlUaO9n.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"http/即时通信几种方案.md","filePath":"http/即时通信几种方案.md","lastUpdated":1715657339000}'),o={name:"http/即时通信几种方案.md"},a=i('<h2 id="即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别" tabindex="-1">即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？ <a class="header-anchor" href="#即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别" aria-label="Permalink to &quot;即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？&quot;">​</a></h2><ol><li>短轮询: 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应</li></ol><ul><li>比较简单，易于理解</li><li>需要不断的建立 http 连接，浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大</li></ul><ol start="2"><li>长轮询:</li></ol><ul><li>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</li><li>客户端响应处理函完服务器返回的信息后，再次发出请求，重新建立连接</li><li>长轮询和短轮询比起来，明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</li></ul><ol start="3"><li>SSE： 服务器使用流信息向服务器推送信息-视频播放</li></ol><ul><li>严格地说，http 协议无法做到服务器主动推送信息。但是服务器向客户端声明，接下来要发送的是流信息，会连续不断地发送过来</li><li>客户端不会关闭连接，会一直等着服务器发过来的新的数据流</li><li>基于 http 协议，目前除了 IE/Edge，其他浏览器都支持</li><li>相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源</li></ul><ol start="4"><li>WebSocket: 全双工双向通信</li></ol><p>上面的四个通信协议，前三个都是基于HTTP协议的。</p><ul><li>从性能的角度来看 WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</li><li>考虑浏览器的兼容性： 短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</li></ul>',10),_=[a];function s(c,r,p,n,h,d){return e(),l("div",null,_)}const E=t(o,[["render",s]]);export{u as __pageData,E as default};
