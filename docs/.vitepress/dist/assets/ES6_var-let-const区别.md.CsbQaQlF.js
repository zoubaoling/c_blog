import{_ as e,c as t,o,a5 as a}from"./chunks/framework.B102yH4G.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/var-let-const区别.md","filePath":"ES6/var-let-const区别.md","lastUpdated":1715864760000}'),c={name:"ES6/var-let-const区别.md"},l=a('<h2 id="var、let、const之间有什么区别" tabindex="-1">var、let、const之间有什么区别 <a class="header-anchor" href="#var、let、const之间有什么区别" aria-label="Permalink to &quot;var、let、const之间有什么区别&quot;">​</a></h2><ul><li>var声明的变量存在<code>变量提升</code>：函数内提升到函数顶部声明，函数外提升到全局顶部声明，在声明之前可以访问，值为undefined，但是let const声明的变量不存在变量提升</li><li>let const声明会造成<code>暂时性死区</code>，在声明之前使用，不可用，会报错</li><li>var 可以<code>重复声明变量</code>，后面的会覆盖前面的。let const在同一作用域下不可以重复声明</li><li>var和let可以<code>修改</code>声明的变量，const声明<code>只读常量</code>，一旦声明不可修改。但如果是引用类型，存储的是引用类型的地址指针，可以修改引用类型的属性，不能修改绑定</li><li><code>块级作用域</code>，let和const存在块级作用域：<code>函数内部、花括号</code>，只在声明的块级作用域内生效，作用域外无法访问, var函数内声明时，是局部的，函数外声明是全局的</li><li>const一旦声明，必须<code>立刻初始化</code>，var和let不需要</li></ul><h3 id="循环中的声明" tabindex="-1">循环中的声明 <a class="header-anchor" href="#循环中的声明" aria-label="Permalink to &quot;循环中的声明&quot;">​</a></h3><p><code>for (var i = 0; xxx)</code></p><ul><li>var声明会提升到顶部作用域，循环内使用的是同一个变量</li><li>let和const声明不会提升在顶部作用域，每一次迭代都会重新生成一个变量，每个循环体内使用的是各自不同的变量</li></ul><p>如果循环体内存在函数访问变量，且是在循环结束后执行，var循环访问到的是顶部作用域的一个变量，是最终值；let和const循环访问到的是每个循环体内单独创建的变量</p>',6),r=[l];function n(s,d,i,_,v,h){return o(),t("div",null,r)}const f=e(c,[["render",n]]);export{u as __pageData,f as default};
