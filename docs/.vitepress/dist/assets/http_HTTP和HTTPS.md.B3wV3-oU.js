import{_ as l,c as i,o as t,a3 as T}from"./chunks/framework.B7tteqv2.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"http/HTTP和HTTPS.md","filePath":"http/HTTP和HTTPS.md","lastUpdated":1715657339000}'),a={name:"http/HTTP和HTTPS.md"},e=T('<h2 id="什么是http-http-和-https-的区别" tabindex="-1">什么是HTTP? HTTP 和 HTTPS 的区别? <a class="header-anchor" href="#什么是http-http-和-https-的区别" aria-label="Permalink to &quot;什么是HTTP? HTTP 和 HTTPS 的区别?&quot;">​</a></h2><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>HTTPS是HTTP协议的安全版本 <ul><li>HTTP协议的数据传输是明文的，是不安全的</li><li>HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</li></ul></li><li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS需要CA证书，HTTP不需要</li><li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li></ul><h3 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h3><p>HTTP (HyperText Transfer Protocol): 超文本运输协议，是实现网络通信的一种规范, 常用于浏览器和服务器之间传递信息，以明文方式发送内容，不进行数据加密 <strong>特点</strong></p><ul><li>支持客户端/服务器模式</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li><li>无状态：HTTP协议无法根据之前的状态进行本次的请求处理</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</li></ul><h3 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h3><p>HTTPS 就是在 HTTP 和 TCP 协议中间加入了 SSL/TLS 安全套接层，即HTTPS = HTTP + SSL/TLS。</p><ul><li>通过 SSL证书来验证服务器的身份</li><li>并为浏览器和服务器之间的通信进行加密（传输层）</li></ul><p><strong>实现：对称加密(会话消息) + 非对称加密(对称密钥) + 数字证书(身份验证+数据完整性)</strong></p><ol><li>浏览器发起HTTPS请求</li><li>客户端将数字证书（包含公钥）返回给浏览器</li><li>浏览器确认身份-数字证书 = 基础信息（公钥、个人信息、其他信息）+ 数字签名</li></ol><ul><li>基础信息 &gt; hash算法 &gt; 消息摘要 &gt; 用CA(证书颁发机构)的私钥加密 &gt; 数字签名</li><li>验证：使用相同的hash算法将基础信息<code>生成消息摘要</code>，再使用CA的公钥对数字签名解密得到<code>CA创建的消息摘要</code>，将二者对比</li></ul><ol start="4"><li>浏览器产生随机对称密钥/会话密钥，用于加解密会话消息</li><li>浏览器使用公钥对对称密钥加密，然后将加密后的对称密钥发送给服务器</li><li>服务器使用私钥解密获得对称密钥</li><li>服务器使用对称密钥加密会话消息并发送给浏览器</li><li>浏览器使用对称密钥解密密文获取消息</li></ol><ul><li>CA的公钥是从浏览器或者操作系统中安装的根证书获取</li><li>HASH算法是在数字证书创建时指定的，并作为证书的一部分发送给客户端</li></ul><p><strong>方案要点</strong></p><ol><li>只有对称加密-对数据加密，机密性</li></ol><ul><li>如果一开始发送对称密钥就被拦截，消息仍然会被窥视和篡改</li></ul><ol start="2"><li>只有非对称加密-对对称密钥加密</li></ol><ul><li>RSA算法比较慢</li></ul><ol start="3"><li>对称加密 + 非对称加密</li></ol><ul><li>及时拦截了数据没有私钥也无法篡改，且块</li></ul><ol start="4"><li>数字证书-确认身份</li></ol><ul><li>中间人攻击，发送证书（公钥）时可能会被拦截篡改，浏览器收到的就是错误的公钥</li><li>引入数字证书，将证书机构生成的消息摘要和自己生成的消息摘要对比</li></ul><h3 id="ca证书流程" tabindex="-1">CA证书流程 <a class="header-anchor" href="#ca证书流程" aria-label="Permalink to &quot;CA证书流程&quot;">​</a></h3><ol><li>证书申请者在自己的服务器上生成一个公钥和私钥</li><li>创建证书签名请求：公钥 + 组织标识信息（网站地址、公司名称等）</li><li>提交申请给证书颁发机构CA，CA验证申请者的信息和其他信息</li><li>验证通过，CA使用CA的私钥对申请者的公钥和其他信息进行签名，生成数字证书（基本信息+签名）并返回给申请者</li><li>申请者将证书安装在服务器上</li></ol>',25),o=[e];function r(P,s,h,H,n,c){return t(),i("div",null,o)}const S=l(a,[["render",r]]);export{u as __pageData,S as default};
