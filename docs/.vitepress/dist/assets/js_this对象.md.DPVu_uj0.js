import{_ as i,c as t,o as e,a5 as l}from"./chunks/framework.B102yH4G.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/this对象.md","filePath":"js/this对象.md","lastUpdated":1715864760000}'),s={name:"js/this对象.md"},n=l('<h2 id="谈谈this对象的理解" tabindex="-1">谈谈this对象的理解 <a class="header-anchor" href="#谈谈this对象的理解" aria-label="Permalink to &quot;谈谈this对象的理解&quot;">​</a></h2><p>大多数情况，函数的调用方式决定了this的值（运行时绑定）</p><p>this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，指向调用它的对象</p><p><strong>this指向</strong></p><ol><li>全局对象中的this指向 <ul><li>指向的是window, 严格模式是undefined</li></ul></li><li>全局作用域或者普通函数中的this <ul><li>指向全局window，严格模式是undefined</li></ul></li><li>作为对象的方法调用，this永远指向最后调用它的那个对象(在不是箭头函数的情况下)</li><li>new 关键词改变了this的指向，箭头函数不可修改 <ul><li>构建函数返回了一个对象，this指向的是这个对象</li><li>否则，this指向的是实例对象</li></ul></li><li>apply,call,bind <ul><li>可以改变this指向，箭头函数不可修改</li></ul></li><li>箭头函数中的this <ul><li>箭头函数的this指向在定义的时候就已经确定了</li><li>箭头函数它没有this, 看外层是否有普通函数，有就是外层函数的this，没有就是window</li></ul></li><li>匿名函数中的this <ul><li>永远指向了window,匿名函数的执行环境具有全局性，因此this指向window</li></ul></li></ol><p>new &gt; call apply bind &gt; 其他</p><h3 id="addeventlistener" tabindex="-1">addEventListener <a class="header-anchor" href="#addeventlistener" aria-label="Permalink to &quot;addEventListener&quot;">​</a></h3><ol><li>使用非箭头函数绑定 <code>element.addEventListener(&#39;click&#39;, function() {})</code>: this绑定的是element，监听事件的元素</li><li>使用箭头函数 <code>element.addEventListener(&#39;click&#39;, () =&gt; {})</code>: this绑定的是window，箭头函数声明在全局作用域下，外部没有函数作用域</li></ol>',8),a=[n];function d(o,h,r,c,_,p){return e(),t("div",null,a)}const w=i(s,[["render",d]]);export{m as __pageData,w as default};
