import{_ as e,c as i,o as l,a5 as t}from"./chunks/framework.B102yH4G.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"webpack/vite的原理.md","filePath":"webpack/vite的原理.md","lastUpdated":1715947066000}'),a={name:"webpack/vite的原理.md"},o=t('<h2 id="vite的原理" tabindex="-1">vite的原理 <a class="header-anchor" href="#vite的原理" aria-label="Permalink to &quot;vite的原理&quot;">​</a></h2><p><strong>开发环境</strong></p><ul><li>直接启动开发服务器，不需要进行打包操作，也就不需要分析模块的依赖、不需要编译，因此启动速度非常快</li><li>真正的按需编译：利用现代浏览器支持ES Module的特性，当浏览器请求(import)某个模块的时候，再根据需要对模块的内容进行编译，大大缩短了编译时间</li><li>Vite中HMR是在原生ESM上执行的。当编辑一个文件时，仅需编译该模块并让浏览器重新请求该模块即可，无须像webpack那样需要把该模块的相关依赖模块全部编译并打包一次，效率更高</li><li>使用esbuild处理项目依赖，esbuild使用go编写，比一般node.js编写的编译器快几个数量级</li></ul><p><strong>生产环境</strong></p><ul><li>集成Rollup打包生产环境代码，依赖其成熟稳定的生态与更简洁的插件机制</li></ul><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ol><li><code>ESbuild编译</code>，esbuild使用go编写，cpu密集下更具性能优势，编译速度更快</li><li><code>依赖预构建</code><ul><li>模块化兼容：Vite在预构建阶段将依赖中各种其他模块化规范(CommonJS、UMD)转换成ESM，以提供给浏览器</li><li>性能优化：npm包中大量的ESM代码，大量的import请求，会造成网络拥塞。Vite使用esbuild，将有大量内部模块的ESM关系转换成单个模块，以减少import模块请求次数。</li></ul></li><li><code>按需加载</code>: 只在接受到import请求的时候，才会编译对应的文件，将ESM源码返回给浏览器，实现真正的按需加载</li><li><code>缓存</code><ul><li>HTTP缓存：充分利用http缓存做优化，依赖（不会变动的代码）部分用max-age,immutable 强缓存，源码部分用304协商缓存，提升页面打开速度。</li><li>文件系统缓存：Vite在预构建阶段，将构建后的依赖缓存到node_modules/.vite ，相关配置更改时，或手动控制时才会重新构建，以提升预构建速度</li></ul></li></ol><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>快！快！非常快！！</li><li>高度集成，开箱即用</li><li>基于ESM急速热更新，无需打包编译</li><li>基于<code>esbuild</code>的依赖预处理，比Webpack的<code>node编写的编译器快</code>几个数量级</li><li>不与Vue绑定，支持React等其他框架，独立的构建工具。</li><li>兼容Rollup庞大的插件机制，插件开发更简洁。</li><li>天然支持TS</li><li>内置SSR支持</li></ul><h3 id="不足" tabindex="-1">不足 <a class="header-anchor" href="#不足" aria-label="Permalink to &quot;不足&quot;">​</a></h3><ul><li>Vue仍为第一优先支持，量身定做的编译插件，对React的支持不如Vue强大</li><li>生产环境集成Rollup打包，与开发环境最(esbuild)终执行的代码不一致</li></ul><p><strong>VS Webpack</strong></p><ul><li>Webpack通过先将整个应用打包，再将打包后代码提供给dev server，开发者才能开始开发</li><li>Vite直接启动开发服务器，不需要进行打包操作，也就不需要分析模块的依赖、不需要编译，因此启动速度非常快, 利用现代浏览器支持ES Module的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，大大缩短了编译时间,真正的按需编译</li></ul><h3 id="vite的构建流程" tabindex="-1">vite的构建流程 <a class="header-anchor" href="#vite的构建流程" aria-label="Permalink to &quot;vite的构建流程&quot;">​</a></h3><ol><li>启动开发服务器：通过运行 vite 命令，Vite启动一个开发服务器，基于原生ESM，不进行打包操作</li><li>当浏览器初始请求时，Vite分析入口文件，解析任何存在的 import语句，递归地查找和加载所有依赖的模块</li><li>Vite会检查模块是否已经被编译，如果没有，根据模块的类型（.js、.vue）采取不同的编译策略实时编译每个模块，真正的按需编译 <ul><li>JS/TS文件，Vite使用esbuild进行快速的原生ES模块转换，生成浏览器可直接执行的代码</li><li>Vue单文件组件（.vue 文件），Vite使用 @vue/compiler-sfc解析并编译它们成为JS代码</li></ul></li><li>完成编译后，Vite 会将模块包裹在一个虚拟模块中，并将模块作为一个请求的响应返回给浏览器。这样浏览器可以直接加载这些虚拟模块，无需打包成独立文件</li><li>文件内容修改时，支持热模块替换（HMR），不需要加载整个页面 <ul><li>vite开发服务器监听到变化重新编译改动文件</li><li>websocket推送消息到浏览器，告知哪些模块需要更新</li><li>浏览器收到更新通知，会请求更新的模块文件，替换旧的模块</li></ul></li></ol><p>webpack会从入口文件开始，分析构建整个应用的依赖树，递归解析所有依赖的模块；</p><p>vite从浏览器请求入口开始，按照import递归查找和加载所有依赖的模块，只加载当前活动页面的所有依赖，而不是整个应用</p><h3 id="hmr应用区别" tabindex="-1">HMR应用区别 <a class="header-anchor" href="#hmr应用区别" aria-label="Permalink to &quot;HMR应用区别&quot;">​</a></h3><ol><li>webpack默认不开启,devServer.hot: true；vite默认开启;vue-cli默认开启</li><li>webpack默认支持:js css;vite默认支持: js css vue; vue-cli: js css vue</li><li>额外配置</li></ol><ul><li>webpack: vue(vue-loader),react(react-hot-loader); 图片和其他资源</li><li>vite/vue-cli: 全局css，某些第三方库</li></ul>',20),r=[o];function c(u,s,d,n,p,h){return l(),i("div",null,r)}const m=e(a,[["render",c]]);export{b as __pageData,m as default};
