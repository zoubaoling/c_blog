import{_ as e,c as l,o as t,a5 as i}from"./chunks/framework.B102yH4G.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue实例挂载.md","filePath":"vue/vue实例挂载.md","lastUpdated":1715938250000}'),a={name:"vue/vue实例挂载.md"},o=i('<h2 id="vue的实例挂载过程" tabindex="-1">vue的实例挂载过程 <a class="header-anchor" href="#vue的实例挂载过程" aria-label="Permalink to &quot;vue的实例挂载过程&quot;">​</a></h2><h3 id="new-vue的过程" tabindex="-1">new Vue的过程 <a class="header-anchor" href="#new-vue的过程" aria-label="Permalink to &quot;new Vue的过程&quot;">​</a></h3><ol><li>初始化生命周期、事件中心（初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件）、渲染函数</li><li>beforeCreate</li><li>初始化: injection &gt; state(props &gt; methods &gt; data &gt; computed &gt; watch) &gt; provide</li><li>created</li><li>$mount 挂载: 编译$mount &gt; 运行$mount（模版编译 -&gt; 模版挂载）</li></ol><h3 id="模版编译阶段" tabindex="-1">模版编译阶段 <a class="header-anchor" href="#模版编译阶段" aria-label="Permalink to &quot;模版编译阶段&quot;">​</a></h3><ol><li>编译$mount: 将template中的原生HTML和非原生HTML内容找出来，经过一系列逻辑处理成渲染函数render，就是编译</li><li>template -&gt; 模版编译 -&gt; render -&gt; VNode -&gt; patch -&gt; 视图 <ol><li>模版编译：template -&gt; 模版编译 -&gt; render</li><li>虚拟DOM：VNode -&gt; patch -&gt; 视图</li></ol></li></ol><h4 id="模版编译" tabindex="-1">模版编译 <a class="header-anchor" href="#模版编译" aria-label="Permalink to &quot;模版编译&quot;">​</a></h4><ol><li><code>parse模版解析</code>，将template解析生成AST语法树 <ul><li>parse: parseHTML -&gt; parseText parseFilters <ul><li>文本</li><li>注释</li><li>DOCTYPE &lt;! DOCTYPE html&gt;</li><li>开始标签</li><li>结束标签</li></ul></li><li>标签根据内容去匹配，使用正则匹配，匹配完创建AST节点。</li><li>文本解析是将parseHTML解析出来的文本内容进一步处理，文本中如果存在变量提取出来二次加工</li></ul></li><li><code>optimize优化阶段</code>：遍历AST语法树，将静态节点打上标记 <ul><li>找出静态节点和静态根节点并打上标记 -&gt; 在patch阶段，静态节点就不需要比对</li><li>模版解析过程中会对节点判断添加type值</li></ul></li><li><code>generate代码生成阶段</code>：将AST语法树转换成渲染函数 <ul><li>递归遍历根据tag data children生成对应的字符串<code>h(tag, data, children)</code>，再将对应字符串转换为可执行的方法</li></ul></li></ol><h3 id="模版挂载阶段" tabindex="-1">模版挂载阶段 <a class="header-anchor" href="#模版挂载阶段" aria-label="Permalink to &quot;模版挂载阶段&quot;">​</a></h3><p>vm.$mount：编译时 &gt; 运行时</p><blockquote><p>beforeMount &gt; 创建vm.$el并替换el &gt; mounted</p></blockquote><ol><li>vm.$mount方法--编译时,模版编译 <ol><li>不能挂载到body和html中(document.body document.documentElement)</li><li>options.render存在，处理传入的template</li><li>处理template <ul><li>存在templaet,解析vue模版文件 <ul><li>如果是字符串类型且以#开头，作为ID获取元素</li><li>如果是节点，直接获取节点内容innerHTML</li><li>否则抛出警告，template不合法</li></ul></li><li>不存在template，根据el选择器获取template outerHTML</li></ul></li><li>编译解析template，得到render函数 <ul><li>将template解析成ast语法树ast tree</li><li>ast tree转换成render语法字符串</li><li>render语法字符串转换成render方法</li></ul></li></ol></li><li>调用mount.call() -&gt; Vue.prototype.$mount(public mount method)方法--运行时，模版挂载 <ol><li>执行mountComponent</li><li>无render，生成空的虚拟节点</li><li>callHook: beforeMount(模版编译解析完成，但是未挂载)</li><li>定义updateComponent更新渲染视图的方法:vm._update(vm._render())-lifecycleMixin中定义的 <ul><li>render: 生成虚拟节点VNode</li><li>update: <code>patch</code>节点,VNode转换为真实的DOM，并更新到页面</li></ul></li><li>创建监听器<code>new Watcher(vm, updateComponent,...)</code>，开启对模版中数据的监控,组件数据变化执行updateComponent函数，并触发 <code>beforeUpdate</code>钩子函数 <ul><li>updateComponent执行使用的数据会被getter拦截，将当前watcher实例添加到数据依赖列表中</li><li>数据变化时通知依赖列表里的依赖，依赖（watcher实例）接收到通知后，执行回调函数，更新视图，触发beforeUpdate</li></ul></li></ol></li></ol>',11),r=[o];function n(d,u,c,p,m,h){return t(),l("div",null,r)}const g=e(a,[["render",n]]);export{_ as __pageData,g as default};
