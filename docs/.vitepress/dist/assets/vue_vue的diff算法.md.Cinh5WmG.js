import{_ as l,c as e,o as d,a3 as i}from"./chunks/framework.COm4hYgr.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue的diff算法.md","filePath":"vue/vue的diff算法.md","lastUpdated":1714487493000}'),o={name:"vue/vue的diff算法.md"},a=i('<h2 id="dom的diff" tabindex="-1">DOM的diff <a class="header-anchor" href="#dom的diff" aria-label="Permalink to &quot;DOM的diff&quot;">​</a></h2><p>DOM-diff即DOM比对又称为patch，给DOM打补丁，使新旧DOM一致</p><p>主要内容：</p><ul><li>创建节点：如果旧节点不存在但是新节点有的，就在旧VNode中创建</li><li>删除节点：如果旧节点中有而新节点中不存在的，就在旧VNode中删除</li><li>更新节点：如果新旧节点中都有的，就以新节点为基准，更新旧VNode的内容</li></ul><blockquote><p>更新节点和更新子节点</p></blockquote><h3 id="创建节点" tabindex="-1">创建节点 <a class="header-anchor" href="#创建节点" aria-label="Permalink to &quot;创建节点&quot;">​</a></h3><p>只有三种类型才会创建节点：元素节点、注释节点、文本节点</p><ol><li>如果是元素节点<code>tag</code>, 创建元素节点，如果存在子节点，递归创建子节点并插入元素节点，再将元素节点插入DOM</li><li>如果是注释节点，创建注释节点并插入DOM</li><li>如果都不是，创建文本节点并插入DOM</li></ol><h3 id="删除节点" tabindex="-1">删除节点 <a class="header-anchor" href="#删除节点" aria-label="Permalink to &quot;删除节点&quot;">​</a></h3><p>调用需要删除节点的父节点进行删除 <code>parentEl.removeChild(el)</code></p><h3 id="更新节点" tabindex="-1">更新节点 <a class="header-anchor" href="#更新节点" aria-label="Permalink to &quot;更新节点&quot;">​</a></h3><ol><li>新节点和旧节点都是静态节点 新旧节点都是静态节点，不会存在变更，不需要处理</li><li>新节点是文本节点</li></ol><ul><li>旧节点是文本节点：如果新旧节点内容不同，将旧节点文本内容替换为新的内容</li><li>旧节点不是文本节点：直接将旧节点的内容设置为文本内容</li></ul><ol start="3"><li>新节点是元素节点</li></ol><ul><li>新节点有子节点，比对新旧节点的子节点 <ul><li>旧节点有子节点，就递归比对新旧节点的子节点</li><li>旧节点没有子节点，将新节点的子节点创建并插入到旧节点中，如果旧节点是文本节点，还需要将文本内容清空</li></ul></li><li>新节点没有子节点，且不是文本节点，那么就是空节点，直接清空旧节点内容即可</li></ul><h3 id="更新子节点" tabindex="-1">更新子节点 <a class="header-anchor" href="#更新子节点" aria-label="Permalink to &quot;更新子节点&quot;">​</a></h3><p>当新旧节点存在子节点时，需要比对更新子节点。 遍历新旧节点的children，进行比对，以新节点为基准，新节点遍历在外层，旧节点遍历在内层，比对更新子节点，主要有以下几种情况： newChildren oldChildren</p><ul><li>创建节点 如果newChildren中的节点在oldChildren中找不到，就说明旧节点不存在内容，需要创建子节点</li><li>删除节点 如果newChildren遍历完，oldChildren中还存在未处理的节点，说明这些节点需要删除</li><li>移动节点 如果newChildren中的节点在oldChildren中也有，但是位置不一样，说明此次变化需要调整位置，以newChildren中的位置为准，调整newChildren中的位置</li><li>更新节点 如果newChildren和oldChildren中找到了相同的内容且位置相同，那么更新oldChildren中的内容与newChildren一致</li></ul><p>创建子节点和移动节点都是插入或者移动到未处理的节点之前（如果是从前往后，那么后续新增的节点会覆盖之前的位置）</p><h3 id="更新优化子节点" tabindex="-1">更新优化子节点 <a class="header-anchor" href="#更新优化子节点" aria-label="Permalink to &quot;更新优化子节点&quot;">​</a></h3><p>比对children是用了两层循环比对的，如果将新节点第一个数据和旧节点所有数据比对，当数据量比较大时，时间复杂度比较高，可以进行优化</p><blockquote><p>同层比较、深度优先，循环从两边向中间聚拢</p></blockquote><ul><li><code>newChildren</code>里未处理的子节点的第一个节点：新前 newStartIdx</li><li><code>newChildren</code>里未处理的子节点的最后一个节点：新后 newEndIdx</li><li><code>oldChildren</code>里未处理的子节点的第一个节点：旧前 oldStartIdx</li><li><code>oldChildren</code>里未处理的子节点的最后一个节点：旧后 oldEndIdx 比对过程 if else/if</li></ul><ol><li>新前与旧前对比，如果相同，直接进入更新节点的操作，<code>newStartIdx</code>和<code>oldStartIdx</code>都+1，往后移动一位</li><li>新后与旧后对比，如果相同，直接进入更新节点的操作，<code>newEndIdx</code>和<code>oldEndIdx</code>都-1，往前移动一位</li><li>新后与旧前对比，如果相同，直接进入更新节点的操作，将旧前节点移动到与新节点中相同的位置，oldStart移动到oldEnd之后，然后<code>newEndIdx</code>-1,<code>oldStartIdx</code>+1</li><li>新前与旧后对比，如果相同，直接进入更新节点的操作，将旧后节点移动到与新节点中相同的位置，oldEnd移动到oldStart之前，然后<code>newStartIdx</code>+1,<code>oldEndIdx</code>-1</li><li>如果都不匹配，在oldChildren中寻找与新前节点相同key的节点</li></ol><ul><li>如果旧节点中找不到相同key的节点，说明新前是一个新的节点，创建节点</li><li>如果旧节点中存在相同key的节点，叫做需要移动的节点 <ul><li>如果新前节点与移动节点相同，直接更新节点内容，将移动节点移动到和新节点中相同位置，旧前节点之前</li><li>如果新前节点与移动节点不相同，创建一个新节点</li></ul></li><li>处理完，newStartIdx往后移动一位</li></ul><ol start="6"><li>循环遍历，知道oldStartIdx &gt; oldEndIdx或着newStartIdx &lt; newEndIdx</li></ol><ul><li>oldStartIdx &gt; oldEndIdx：旧节点先处理完，新节点中剩下的未处理节点都是新增的节点</li><li>newStartIdx &gt; newEndIdx: 新节点先处理完，旧节点中剩下未处理节点都是要删除的节点</li></ul>',27),t=[a];function n(r,c,h,u,s,f){return d(),e("div",null,t)}const _=l(o,[["render",n]]);export{x as __pageData,_ as default};
