import{_ as e,c as t,o as a,a3 as i}from"./chunks/framework.COm4hYgr.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/怎么理解ES6的proxy.md","filePath":"ES6/怎么理解ES6的proxy.md","lastUpdated":1714567771000}'),s={name:"ES6/怎么理解ES6的proxy.md"},r=i(`<h2 id="你是怎么理解es6中proxy的-使用场景有哪些" tabindex="-1">你是怎么理解ES6中Proxy的？使用场景有哪些 <a class="header-anchor" href="#你是怎么理解es6中proxy的-使用场景有哪些" aria-label="Permalink to &quot;你是怎么理解ES6中Proxy的？使用场景有哪些&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p>用于定义基本操作的自定义行为，创建指定对象的代理，实现基本操作的拦截和自定义</p><h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h3><p>new Proxy接收两个参数</p><ul><li>第一个是需要拦截的对象</li><li>第二个是自定义行为handler，一个包含了各种函数属性的对象，定义了个操作的代理行为 handler支持的拦截属性</li><li>get(target, propKey, receiver) 拦截属性的读取</li><li>set(target, propKey, value, receiver) 拦截属性的设置</li><li>deleteProperty(target, propKey) 拦截属性的删除</li><li>ownKeys(target) 拦截Object.keys和for in、Object.assign、Object.getOwnPropertyNames、Object.getOwnPropertySymbols等循环，返回一个数组</li><li>apply(target, object, arts) 调用一个函数</li><li>construct(target, arts) 拦截new调用一个函数</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象</li><li>has(target, propKey), 拦截in操作符</li></ul><p>代理撤销 <code>Proxy.revocable</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Proxy.revocable</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// revoke执行后，proxy不可用</span></span></code></pre></div><p>Reflect拥有proxy支持的代理行为的同名方法，可以改变一些默认行为，比如异常时不是报错，而是返回false</p><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><ul><li><p>拦截和监听外部对对象的访问</p></li><li><p>在复杂操作前对操作进行校验或对所需资源进行管理</p></li><li><p>[ ] Proxy各实例讲解 深入理解ES6</p></li></ul>`,11),l=[r];function o(p,n,h,c,d,y){return a(),t("div",null,l)}const E=e(s,[["render",o]]);export{g as __pageData,E as default};
