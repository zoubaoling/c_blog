import{_ as e,c as l,o,a5 as i}from"./chunks/framework.B102yH4G.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue3原理.md","filePath":"vue/vue3原理.md","lastUpdated":1716116812000}'),c={name:"vue/vue3原理.md"},t=i('<h2 id="vue3原理" tabindex="-1">vue3原理 <a class="header-anchor" href="#vue3原理" aria-label="Permalink to &quot;vue3原理&quot;">​</a></h2><h3 id="核心模块" tabindex="-1">核心模块 <a class="header-anchor" href="#核心模块" aria-label="Permalink to &quot;核心模块&quot;">​</a></h3><ol><li><code>Reactive</code>: 响应式处理 <ul><li>使用<code>track, trigger, effect</code>跟踪收集依赖并触发变化</li><li><code>proxy</code>代理, <code>get</code>: track, <code>trigger</code>: set</li><li><code>effect</code>: 用于组件渲染、computed数据、watch数据, 类似vue2的watch，添加数据响应时的副作用(重新渲染、重新计算、调用侦听回调函数)</li></ul></li><li><code>Compiler</code>: 编译模版，将HTML编译成render/h渲染函数</li><li><code>mount</code>: 根据渲染函数生成VNode，将组件渲染挂载到web页面上 <ul><li><code>createVNode</code>: 执行<code>createAppAPI/createApp/app/mount/createVNode</code>获取VNode</li><li><code>render</code>: 接收VNode,执行render渲染器, 进行DOM操作挂载到页面</li><li><code>patch</code>: 接收新旧两个VNode, 进行diff比对，进行局部更新</li></ul></li></ol><h4 id="一个简单组件的执行" tabindex="-1">一个简单组件的执行 <a class="header-anchor" href="#一个简单组件的执行" aria-label="Permalink to &quot;一个简单组件的执行&quot;">​</a></h4><ol><li>createApp执行，初始化应用</li><li><code>baseCreateRnderer</code>, 创建更新渲染函数和渲染effect, 将组件更新渲染函数作为副作用传入渲染effect，方便后期更新</li><li>默认执行<code>effect.run</code>: 将<code>activeEffect</code>设置为this-渲染effect, 然后执行更新渲染函数(执行完毕弹出activeEffect)</li><li><code>Compiler</code>模版编译将HTML/Template编译成渲染函数</li><li>创建响应式数据在模版中绑定，并通过proxy进行代理</li><li>渲染函数执行 <ul><li>读取响应式数据，被get拦截，调用<code>track</code>进行依赖收集,将渲染effect-(副作用为更新渲染函数)添加进数据属性的依赖池里</li><li><code>render</code>函数返回一个虚拟DOM节点</li></ul></li><li>挂载阶段<code>mount</code>, 将虚拟节点挂载到web</li><li>后续响应数据变化，执行<code>trigger</code>触发更新, 根据数据属性的依赖池遍历执行effect--更新渲染函数</li><li>执行path，进行diff比对</li></ol><h3 id="响应式" tabindex="-1">响应式 <a class="header-anchor" href="#响应式" aria-label="Permalink to &quot;响应式&quot;">​</a></h3><h4 id="reactive" tabindex="-1">reactive <a class="header-anchor" href="#reactive" aria-label="Permalink to &quot;reactive&quot;">​</a></h4><p>reactive.ts: 整体思想和vue2类似，对数据通过拦截进行响应式处理，<code>get</code>收集依赖，<code>set</code>触发依赖</p><ol><li><code>reactive.ts</code>中使用<code>proxy</code>进行代理，<code>proxy(target, handler)</code></li><li><code>baseHandlers.ts</code>中对各类操作进行代理 <ul><li><code>get</code>使用<code>track</code>收集依赖, 通过Map管理，添加activeEffect-渲染effect, computed effect, watch effect</li><li><code>set</code>使用<code>trigger</code>触发事件, 触发对应的effect添加的副作用-重新渲染，重新计算计算属性，调用侦听函数</li></ul></li></ol><h4 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;ref&quot;">​</a></h4><p>ref可以看作reactive的变形版本<code>{value: toReactive(value)}</code>，class类实现</p><ol><li>使用<code>reactive</code>将值转换为响应式</li><li>设置<code>get value</code>，使用track收集依赖，并返回处理后的响应式对象</li><li>设置<code>set value</code>, 使用trigger触发依赖</li></ol><h4 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h4><p>和<code>ref</code>类似</p><ol><li>处理参数，可以是getter方法, 也可以是包含[get, set]的对象</li><li>初始化一个<code>ComputedRefImpl</code>实例</li><li>创建一个computed effect, 将<code>getter(this._value)</code>函数作为副作用传入computed effect, 便于后期触发依赖重新计算computed</li><li>设置类<code>get value</code>, 所以使用类似ref，通过.value获取 <ul><li>获取原始对象</li><li>检查是否需要重新计算(比对_value和effect.run--getter)，如果需要则执行trigger执行前面传入的<code>getter(this._value)</code>即重新计算值并更新值</li><li>执行track收集对计算属性的依赖，比如渲染effect</li><li>返回_value</li></ul></li><li>设置类<code>set value</code>, 执行初始化传入的option.set函数</li></ol><div class="tip custom-block"><p class="custom-block-title">提示</p><ol><li>computed effect订阅其中使用的响应式数据，当响应式数据变化时重新执行computed effect的getter(_value)重新计算值--在第一次渲染计算值的时候会访问响应式数据</li><li>渲染effect订阅computed effect，computed更新时重新执行渲染effect的更新渲染函数--第一次渲染初始化时订阅</li></ol></div><h4 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h4><ul><li>根据传入来源参数形式处理<code>getter</code></li><li>根据<code>flush</code>参数处理<code>schedule</code></li><li>创建watch effect，传入<code>getter和schedule</code>--当前渲染watcher监听watch effect <ul><li>执行effect.run-&gt; getter，重新计算监听值，将新值和旧值传入回调函数，<code>watchEffect</code>则直接执行副作用</li><li>计算值时，访问其他响应式变量，当前watch effect订阅响应式变量属性</li></ul></li></ul><h3 id="编译-渲染" tabindex="-1">编译 &amp; 渲染 <a class="header-anchor" href="#编译-渲染" aria-label="Permalink to &quot;编译 &amp; 渲染&quot;">​</a></h3><p><strong>vue3里编译和渲染是分开的，编译由vite构建工具执行， 开发时可以快速的热更新</strong></p><ol><li><code>编译</code> compile.ts/baseCompile对模块进行编译, 获取渲染函数<code>h()</code>: parse &gt; optimize &gt; generate <ol><li>编译是vite构建工具执行的，开发时按需编译，构建时构建整个应用</li><li>根据入口配置，将import相关的文件经过解析、优化、生成代码，最终编译成渲染函数<code>h()</code></li><li>各模块编译后的渲染函数会存储在vite本地开发服务器内存中, 由vite将编译后的渲染函数提供给渲染器</li></ol></li><li><code>渲染</code> createApp, 将编译后的渲染函数<code>h()</code>通过渲染器render转换成虚拟DOM节点，再mount处理为真实DOM并挂载在页面上 <ol><li>浏览器访问URL</li><li>访问入口文件，执行<code>createApp(App)</code>,此时获取到的是vite提供的编译后的根模块的渲染函数</li><li>将编译后的入口模块返回给浏览器</li><li>渲染器渲染根文件的渲染函数，并根据依赖关系使用渲染器渲染编译后的各子模块的渲染函数<code>h()</code></li><li>浏览器里页面按需加载成功</li><li>修改文件，渲染器根据之前编译处理得到的渲染函数来进行重新渲染，而不是重新编译</li><li>重新执行vite编译命令会重新编译</li></ol></li></ol><div class="tip custom-block"><p class="custom-block-title">编译：vue2 VS vue3</p><ol><li>大阶段都为解析为AST，优化、生成代码</li><li>vue3的优化更灵活，引入了静态标记、静态提升和内联函数缓存等，提高了渲染性能和开发体验</li><li>最终都会生成渲染函数，vue2主要是通过<code>new Function</code>来生成字符串形式的函数; vue3则更加灵活，具体实现有所不同</li></ol></div><h3 id="编译" tabindex="-1">编译 <a class="header-anchor" href="#编译" aria-label="Permalink to &quot;编译&quot;">​</a></h3><h4 id="核心步骤" tabindex="-1">核心步骤 <a class="header-anchor" href="#核心步骤" aria-label="Permalink to &quot;核心步骤&quot;">​</a></h4><p><code>compile.ts/baseCompile</code></p><ol><li><code>parse</code>解析，模版字符串转换为AST语法树，包括标签、属性、指令、文本等</li><li><code>optimization/transform</code>优化，遍历AST，标记静态节点、静态提升、内联函数缓存 <ul><li><code>静态标记</code> traverseNode/nodeTransforms 遍历AST语法树，进行静态标记和内联函数缓存 <ul><li>静态节点: 后期更新diff时不被比对; eg: transformElement, transformText</li><li>内联函数缓存: 追踪和优化变量引用，不会每次都创建内联函数，只需创建一次; eg: transformExpression</li></ul></li><li><code>静态提升 hoistStatic</code> 遍历AST树，找出静态子树并提升到root.hoists中即顶级作用域，这样静态节点只需要在组件初始渲染时执行一次，减少不必要的计算和创建</li></ul></li><li><code>generation</code>代码生成，将标记后的AST转换成可执行的渲染函数render</li></ol><h3 id="mount" tabindex="-1">mount <a class="header-anchor" href="#mount" aria-label="Permalink to &quot;mount&quot;">​</a></h3><p>创建应用实例 -&gt; 将应用实例挂载到容器上 -&gt; 创建虚拟节点 -&gt; 执行渲染函数 -&gt; 将虚拟节点转换为真实DOM并挂载到页面上 -&gt; 后续数据更新时通过更新函数重新渲染 将渲染函数转换为VNode，将VNode转换为真实DOM挂载到页面，数据更新后，会patch比对更新页面</p><ol><li><code>createApp/baseCreateRender</code>里初始化 <ol><li><code>createApp</code>创建应用实例，并设置全局配置</li><li><code>baseCreateRender</code>创建渲染器，初始化render、patch、mountXxx、updateXxx等方法,返回<code>render createApp/createAppAPI(render, ..)</code></li></ol></li><li>根据创建的app实例, 初始化实例的<code>mount</code>等方法 <ol><li>处理container容器: element | string等，然后执行mount(createAppAPI里声明) <ol><li>createVNode创建虚拟节点</li><li>执行render函数结合编译后的模块render渲染函数属性 <ol><li>patch函数，根据类型(组件、元素、节点等)将VNode转换为真实DOM并挂载，初始挂载时会创建渲染effect并绑定更新函数</li><li>更新的话则会执行对应的更新函数</li></ol></li></ol></li></ol></li></ol><h3 id="diff" tabindex="-1">diff <a class="header-anchor" href="#diff" aria-label="Permalink to &quot;diff&quot;">​</a></h3><h4 id="优化点" tabindex="-1">优化点 <a class="header-anchor" href="#优化点" aria-label="Permalink to &quot;优化点&quot;">​</a></h4><ol><li>静态标记，更新过程中跳过对静态节点的比对</li><li>递归更新，更新一个节点会递归的更新子节点，高效处理嵌套结构，vue2时迭代的</li><li>动态选择算法，根据节点的动态特征选择合适的比对算法，比如，只有属性变化没有子节点变化的节点，采用快速路径跳过子节点的比对</li><li>fragments优化</li></ol><h4 id="主要方向" tabindex="-1">主要方向 <a class="header-anchor" href="#主要方向" aria-label="Permalink to &quot;主要方向&quot;">​</a></h4><ol><li>相同节点复用</li><li>创建并插入新增的节点</li><li>元素位置变化，移动需要移动的元素</li></ol><h4 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h4><p>同层比较，子节点主要分为有key和无key: <code>patchChildren: patchKeyedChildren + patchUnkeyedChildren</code></p><h5 id="patchunkeyedchildren" tabindex="-1">patchUnkeyedChildren <a class="header-anchor" href="#patchunkeyedchildren" aria-label="Permalink to &quot;patchUnkeyedChildren&quot;">​</a></h5><ol><li>直接轮训，头从遍历children节点，进行patch，比对新旧节点 <ol><li>类型相同则复用，还要继续比对虚拟DOM的属性、内容等，递归比对</li><li>节点类型不同，删除旧节点，创建新节点</li></ol></li><li>轮训完后，如果新子节点有余则添加节点，如果旧子节点有余则删除节点</li></ol><h5 id="patchkeyedchildren" tabindex="-1">patchKeyedChildren <a class="header-anchor" href="#patchkeyedchildren" aria-label="Permalink to &quot;patchKeyedChildren&quot;">​</a></h5><ol><li><code>从前往后比对</code>: <code>while</code>i = 0且小于两数组长度，<code>从前往后</code>比对新旧节点，节点类型和key相同复用; 当节点不同时break，停止对比--<code>i++</code></li><li><code>从后往前比对</code>: <code>while</code>i = 0且小于两数组长度，<code>从后往前</code>比对新旧节点，节点类型和key相同复用; 当节点不同时break，停止对比--<code>e1--;e2--</code></li><li><code>新节点列表有新增节点</code>: <code>i &gt; e1 &amp;&amp; i &lt; e2</code>时，新节点列表有要新增的节点，patch新增节点</li><li><code>旧节点列表有需要删除的节点</code>: <code>i &gt; e2 &amp;&amp; i &lt; e1</code>时，新节点列表有要删除的节点，unmount卸载节点</li><li><code>中间乱序节点比对</code>: <code>i &lt; e1 &amp;&amp; i &lt; e2</code>时，首位两次比对新旧都未被全部覆盖到，中间存在乱序节点(ab[cde]fg、ab[edch]fg) <ol><li>新增指针<code>s1和s2</code>，分别指向i停止的地方</li><li>从s2开始遍历新节点列表，将中间的乱序部分存储在映射表Map中</li><li>从s1开始遍历旧节点列表，查找映射表中是否存在该元素: 通过key，没有key则再次遍历新节点列表进行比对获取新节点索引，删除或patch(o, n)更新新旧节点</li><li>从新节点乱序结束的位置开始递减遍历 <ol><li>上述未处理过的节点(标记为0)就是新增的节点，patch(null, n)新增节点</li><li>上述中如果标记存在移动节点，移动节点顺序</li></ol></li></ol></li></ol><div class="tip custom-block"><p class="custom-block-title">diff: v3 VS v2</p><ol><li>vue2是同层比较、深度优先，循环从两边向中间聚拢</li><li>vue3是从前往后、从后往前的双端比较策略，针对<code>中间乱序(LIS最长递增子序列)</code>进行高效处理</li><li>都会双端比对 <ol><li>vue2是对比四个端点后复用并移动后，从新列表索引开始往后查询旧列表中要删除、新增或移动的节点;</li><li>vue3是比对两端可复用的多个前置和后置节点，中间乱序部分查找删除、新增货移动的节点</li></ol></li><li>vue3通过静态提升、静态标记、内联函数缓存等提升了性能，vue2相对逊色</li></ol></div><p><strong>参考链接</strong></p><p><a href="https://segmentfault.com/a/1190000044835898" target="_blank" rel="noreferrer">vue3 diff算法参考</a></p><p><a href="https://blog.csdn.net/weixin_42254016/article/details/138678730" target="_blank" rel="noreferrer">vue2和vue3diff比对</a></p>',44),a=[t];function d(r,h,n,u,p,s){return o(),l("div",null,a)}const v=e(c,[["render",d]]);export{m as __pageData,v as default};
