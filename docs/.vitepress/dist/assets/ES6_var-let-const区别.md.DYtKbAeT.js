import{_ as t,c as a,o as e,a3 as l}from"./chunks/framework.BmlUaO9n.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/var-let-const区别.md","filePath":"ES6/var-let-const区别.md","lastUpdated":1714567771000}'),o={name:"ES6/var-let-const区别.md"},r=l('<h2 id="var、let、const之间有什么区别" tabindex="-1">var、let、const之间有什么区别 <a class="header-anchor" href="#var、let、const之间有什么区别" aria-label="Permalink to &quot;var、let、const之间有什么区别&quot;">​</a></h2><ul><li>var声明的变量存在变量提升：函数内提升到函数顶部声明，函数外提升到全局顶部声明，在声明之前可以访问，值为undefined，但是let const声明的变量不存在变量提升</li><li>let const声明会造成暂时性死区，在声明之前使用，不可用，会报错</li><li>var 可以重复声明变量，后面的会覆盖前面的。let const在同一作用域下不可以重复声明</li><li>var和let可以修改声明的变量，const声明只读常量，一旦声明不可修改。但如果是引用类型，存储的是引用类型的地址指针，可以修改引用类型的属性，不能修改绑定</li><li>块级作用域，let和const存在块级作用域：函数内部、花括号，只在声明的块级作用域内生效，作用于外无法访问, var函数内声明时，是局部的，函数外声明是全局的</li><li>const一旦声明，必须立刻初始化，var和let不需要</li></ul><h3 id="循环中的声明" tabindex="-1">循环中的声明 <a class="header-anchor" href="#循环中的声明" aria-label="Permalink to &quot;循环中的声明&quot;">​</a></h3><p>for (var i = 0; xxx)</p><ul><li>var声明会提升到顶部作用域，循环内使用的是同一个变量</li><li>let和const声明不会提升在顶部作用域，每一次迭代都会重新生成一个变量，每个循环体内使用的是各自不同的变量 如果循环体内存在函数访问变量，且是在循环结束后执行，var循环访问到的是顶部作用域的一个变量，是最终值；let和const循环访问到的是每个循环体内单独创建的变量</li></ul>',5),n=[r];function s(i,c,_,d,v,h){return e(),a("div",null,n)}const f=t(o,[["render",s]]);export{u as __pageData,f as default};
