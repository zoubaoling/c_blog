import{_ as l,c as i,o as e,a5 as a}from"./chunks/framework.B102yH4G.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"http/HTTP和HTTPS.md","filePath":"http/HTTP和HTTPS.md","lastUpdated":1716005365000}'),o={name:"http/HTTP和HTTPS.md"},t=a('<h2 id="什么是http-http-和-https-的区别" tabindex="-1">什么是HTTP? HTTP 和 HTTPS 的区别? <a class="header-anchor" href="#什么是http-http-和-https-的区别" aria-label="Permalink to &quot;什么是HTTP? HTTP 和 HTTPS 的区别?&quot;">​</a></h2><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ol><li>HTTPS是HTTP协议的安全版本 <ul><li>HTTP协议的数据传输是<code>明文</code>的，是不安全的</li><li>HTTPS使用了<code>SSL/TLS协议</code>进行了加密处理，相对更安全</li></ul></li><li>HTTP和HTTPS使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS需要CA证书，HTTP不需要</li><li>HTTPS由于需要涉及加密以及多次握手，性能方面不如HTTP</li></ol><h3 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h3><p><code>HTTP (HyperText Transfer Protocol)</code> 超文本传输协议，是实现网络通信的一种规范, 常用于浏览器和服务器之间传递信息，以明文方式发送内容，不进行数据加密</p><h4 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h4><ul><li>支持客户端/服务器模式</li><li><code>无连接</code> 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li><li><code>无状态</code> HTTP协议无法根据之前的状态进行本次的请求处理</li><li><code>灵活</code> HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</li></ul><h3 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h3><p>HTTPS就是在<code>HTTP和TCP协议中间</code>加入了SSL/TLS安全套接层，即<code>HTTPS = HTTP + SSL/TLS</code></p><ul><li>通过SSL<code>证书</code>来<code>验证</code>服务器的身份</li><li>并为浏览器和服务器之间的通信进行<code>加密</code>（传输层）</li></ul><h4 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h4><div class="tip custom-block"><p class="custom-block-title">提示</p><p><strong>对称加密(会话消息) + 非对称加密(对称密钥) + 数字证书(身份验证+数据完整性)</strong></p></div><ol><li>浏览器发起HTTPS请求</li><li>客户端将数字证书（包含公钥）返回给浏览器</li><li>浏览器确认身份-数字证书 = 基础信息（公钥、HASH算法、个人信息、其他信息）+ 数字签名 <ul><li>CA: 基础信息 &gt; hash算法 &gt; 消息摘要 &gt; 用CA(证书颁发机构)的私钥加密 &gt; 数字签名</li><li>验证: 使用相同的hash算法将基础信息<code>生成消息摘要</code>，再使用CA的公钥对数字签名解密得到<code>CA创建的消息摘要</code>，将二者对比</li></ul></li><li>浏览器<code>随机产生对称密钥</code>/会话密钥，用于加解密会话消息</li><li>浏览器使用<code>公钥</code>对对称密钥加密，然后将<code>加密后的对称密钥</code>发送给服务器</li><li>服务器使用<code>私钥</code>解密获得<code>对称密钥</code></li><li>服务器使用对称密钥加密会话消息并发送给浏览器</li><li>浏览器使用对称密钥解密密文获取消息</li></ol><h4 id="方案要点" tabindex="-1">方案要点 <a class="header-anchor" href="#方案要点" aria-label="Permalink to &quot;方案要点&quot;">​</a></h4><ol><li>只有对称加密-对数据加密，机密性 <ul><li>如果一开始发送对称密钥就被拦截，消息仍然会被窥视和篡改</li></ul></li><li>只有非对称加密-对对称密钥加密 <ul><li>RSA算法比较慢</li></ul></li><li>对称加密 + 非对称加密 <ul><li>即时拦截了数据没有私钥也无法篡改，且块</li></ul></li><li>数字证书-确认身份 <ul><li>中间人攻击，发送证书（公钥）时可能会被拦截篡改，浏览器收到的就是错误的公钥</li><li>引入数字证书，将证书机构生成的消息摘要和自己生成的消息摘要对比</li></ul></li></ol><h4 id="ca证书流程" tabindex="-1">CA证书流程 <a class="header-anchor" href="#ca证书流程" aria-label="Permalink to &quot;CA证书流程&quot;">​</a></h4><ol><li>证书申请者在自己的服务器上生成一个公钥和私钥</li><li>创建证书签名请求：公钥 + 组织标识信息（网站地址、公司名称等）</li><li>提交申请给证书颁发机构CA，CA验证申请者的信息和其他信息</li><li>验证通过，CA使用CA的私钥对申请者的公钥、HASH算法、公司信息和其他信息进行签名，生成数字证书（基本信息+签名）并返回给申请者 <ul><li>HASH算法是在创建证书时指定的，并作为证书的一部分</li></ul></li><li>申请者将证书安装在服务器上、操作系统或浏览器中(浏览器使用的CA公钥就是从安装的证书中获取，从而对证书的签名解密)</li></ol>',17),T=[t];function c(d,r,h,P,s,n){return e(),i("div",null,T)}const S=l(o,[["render",c]]);export{u as __pageData,S as default};
