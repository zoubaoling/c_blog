import{_ as l,c as i,o as t,a3 as e}from"./chunks/framework.BmlUaO9n.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/js的类型转换.md","filePath":"js/js的类型转换.md","lastUpdated":1714650100000}'),a={name:"js/js的类型转换.md"},n=e('<h2 id="谈谈-javascript-中的类型转换机制" tabindex="-1">谈谈 JavaScript 中的类型转换机制 <a class="header-anchor" href="#谈谈-javascript-中的类型转换机制" aria-label="Permalink to &quot;谈谈 JavaScript 中的类型转换机制&quot;">​</a></h2><p>代码运行时，在计算过程中，如果变量的类型与预期不符，就会触发类型转换</p><ul><li>强制转换/显示转换</li><li>自动转换/隐式转换</li></ul><h3 id="强制转换" tabindex="-1">强制转换 <a class="header-anchor" href="#强制转换" aria-label="Permalink to &quot;强制转换&quot;">​</a></h3><ul><li><p>Number</p><ul><li>undefined &gt; NaN</li><li>null, false &gt; 0, true &gt; 1</li><li>Symbol报错</li><li>string,必须完全是数字才能转换为数字，否则为NaN；&#39;32&#39; &gt; 32, &#39;32a&#39; &gt; NaN,空字符串为0（含空格）</li><li>object，只有单个数字元素的数组可以转为数字<code>[4]</code>，其他都转为NaN, 空数组转为0</li></ul></li><li><p>Boolean</p><ul><li>转换为false的值：false, &#39;&#39;, 0, +0, -0, undefined, null, NaN</li></ul></li><li><p>String: 任意类型的值转换为字符串</p><ul><li>undefined &gt; &#39;undefined&#39;, null &gt; &#39;null&#39;, true &gt; &#39;true&#39;, false &gt; &#39;false&#39;</li><li>数字型: 0 &gt; &#39;0&#39;, Infinity &gt; &#39;infinity&#39;, -Infinity &gt; &#39;-Infinity&#39;, NaN &gt; &#39;NaN&#39;</li><li>Symbol(key) -&gt; &#39;Symbol(key)&#39;</li><li>Object: 先调用toPrimitive,再调用toNumber <ul><li>{} &gt; &#39;[object Object]&#39;，对象会调用toString()</li><li>[1, 2, &#39;x&#39;] &gt; &#39;1, 2, x&#39;,数组会调用join()，默认逗号分割</li><li>new Set([1, 2]) &gt; &#39;[object Set]&#39;, 调用toString,Map|WeakMap|WeakSet同理</li><li>new Function &gt; &#39;function...&#39;，返回源代码字符串</li><li>new Date &gt; &#39;Ar...&#39;，调用toString()，返回日期和时间信息</li></ul></li></ul></li><li><p>parseInt: 逐个解析字符，不能转换的就停止</p><ul><li>parseInt(&#39;22a&#39;) &gt; 22</li><li>parseInt(&#39;abc2&#39;) &gt; NaN</li></ul></li></ul><h3 id="隐式转换" tabindex="-1">隐式转换 <a class="header-anchor" href="#隐式转换" aria-label="Permalink to &quot;隐式转换&quot;">​</a></h3><p>再遇到运算符的时候，运算符两边类型不一致时会发生转换</p><ul><li>比较运算符：&lt; &gt; == != if while需要布尔值的地方</li><li>算术运算符：+ - * /%</li></ul><ol><li>自动转为布尔值</li></ol><blockquote><p>需要布尔值的地方会自动转为布尔值，会调用Boolean函数：if while 逻辑非! 只有几种会转为false,其他都为true: null, undefined, 0, -0, +0, NaN, &#39;&#39;, false</p></blockquote><ol start="2"><li><p>自动转为字符串 现将复合类型转为原始类型，再将原始类型转为字符串，常用于 +，如果存在字符串，就会进行字符串拼接,模版字符串 具体转换规则见上强制转换中的string型</p></li><li><p>自动转为数字 运算符都会自动转为数值，除了+遇到字符时 数值转换规则见上强制转换中的number型，注意undefined和null</p></li></ol>',11),o=[n];function r(s,u,c,p,d,_){return t(),i("div",null,o)}const h=l(a,[["render",r]]);export{g as __pageData,h as default};
