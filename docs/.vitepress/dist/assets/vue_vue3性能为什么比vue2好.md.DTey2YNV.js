import{_ as e,c as l,o as t,a5 as o}from"./chunks/framework.B102yH4G.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue3性能为什么比vue2好.md","filePath":"vue/vue3性能为什么比vue2好.md","lastUpdated":1715938250000}'),i={name:"vue/vue3性能为什么比vue2好.md"},u=o('<h2 id="vue3的性能为什么比vue2好" tabindex="-1">vue3的性能为什么比vue2好？ <a class="header-anchor" href="#vue3的性能为什么比vue2好" aria-label="Permalink to &quot;vue3的性能为什么比vue2好？&quot;">​</a></h2><ol><li><code>编译阶段</code><ul><li><code>diff算法优化</code>：更新时，静态部分编译时会被标记，diff时只会比对非静态节点和动态属性，减少了需要进行diff的节点数量，从而提高了性能</li><li><code>静态提升</code>：静态内容会做静态提升，只会被创建一次，在渲染时直接复用，避免去重复的创建节点，优化了运行时候的内存占用</li><li><code>事件监听缓存</code><ul><li>缓存内联函数，避免每次渲染重新创建。除非依赖的响应式数据变化，否则不会重新创建函数，减少了不必要的内存分配和垃圾回收</li></ul></li></ul></li><li><code>源码体积</code><ul><li>移除了一些不常用的API: filters $destroy EventBus $on/$off/$once Vue.set Vue.delete</li><li>使用tree-shaking, 只打包使用的模块</li></ul></li><li><code>响应式系统</code><ul><li>使用proxy替代defineProperty，可以直接监听整个对象，不用遍历属性</li><li>vue3不会初始时递归遍历属性做响应式处理，只有在实际需要时(getter拦截器中)才将对象的对象属性转换为响应式的，减少不必要的性能开销</li></ul></li></ol>',2),a=[u];function d(c,_,r,s,n,v){return t(),l("div",null,a)}const h=e(i,[["render",d]]);export{p as __pageData,h as default};
