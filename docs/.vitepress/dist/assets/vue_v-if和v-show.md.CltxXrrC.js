import{_ as e,c as o,o as a,a3 as t}from"./chunks/framework.COm4hYgr.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/v-if和v-show.md","filePath":"vue/v-if和v-show.md","lastUpdated":1714298906000}'),i={name:"vue/v-if和v-show.md"},l=t('<h3 id="v-if和v-show的共同点" tabindex="-1">v-if和v-show的共同点 <a class="header-anchor" href="#v-if和v-show的共同点" aria-label="Permalink to &quot;v-if和v-show的共同点&quot;">​</a></h3><p>都是控制元素在页面的显隐，为true时，页面上展示；为false，不在页面上展示</p><h3 id="不同点" tabindex="-1">不同点 <a class="header-anchor" href="#不同点" aria-label="Permalink to &quot;不同点&quot;">​</a></h3><ul><li>控制手段不同</li><li>编译过程不同</li><li>编译条件不同</li><li>性能消耗不同</li></ul><p>控制手段：<code>v-show</code>是通过css的display属性控制的元素的显隐；<code>v-if</code>是控制DOM元素的增加和删除 编译过程：<code>v-show</code>只涉及到简单的CSS切换；<code>v-if</code>如果其中包裹组件的话，会涉及到销毁和重建内部的事件监听和子组件 编译条件： <code>v-if</code>是真正的条件渲染，只有条件为true时，组件才会渲染；</p><ul><li>v-show切换时，不会出发组件的生命周期</li><li>v-if由false &gt; true时，会触发子组件的beforeCreate,create,beforeMount,mount；由true &gt; false时，会触发子组件的beforeDestroy,destroyed 性能消耗：<code>v-if</code>有更高的切换消耗，<code>v-show</code>有更高的初始渲染消耗（不管初始条件是什么，组件总会被渲染）</li></ul><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><ul><li><code>v-if</code>适用于条件很少改变的情况</li><li><code>v-show</code>适用于条件频繁改变的情况</li></ul>',8),s=[l];function c(d,r,h,v,f,n){return a(),o("div",null,s)}const p=e(i,[["render",c]]);export{u as __pageData,p as default};
