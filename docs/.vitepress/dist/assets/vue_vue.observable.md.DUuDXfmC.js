import{_ as e,c as a,o as t,a3 as r}from"./chunks/framework.COm4hYgr.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue.observable.md","filePath":"vue/vue.observable.md","lastUpdated":1714384646000}'),l={name:"vue/vue.observable.md"},o=r('<h2 id="vue-observable你有了解过吗-说说看" tabindex="-1">Vue.observable你有了解过吗？说说看 <a class="header-anchor" href="#vue-observable你有了解过吗-说说看" aria-label="Permalink to &quot;Vue.observable你有了解过吗？说说看&quot;">​</a></h2><h3 id="做了什么" tabindex="-1">做了什么 <a class="header-anchor" href="#做了什么" aria-label="Permalink to &quot;做了什么&quot;">​</a></h3><p>Vue.observable将一个对象变成响应式对象，数据更新时，视图可随之更新。 vue2中是直接对原对象进行修改，vue3不会修改原对象，而是返回一个代理对象(observable遗弃，变更为reactive)</p><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p>非父子组件通信时，可以作为最小单位（简单）的跨组件通信状态存储器</p><ul><li>使用Vue.observable创建state</li><li>创建mutations方法修改state的值</li><li>template中直接使用state和mutation</li></ul><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>实际上就是vue内部的响应式实现</p><ul><li>数组：数组方法进行重写，从而拦截</li><li>对象：遍历对象属性，每个属性进行拦截，get收集依赖，set通知观察者 <a href="https://vue3js.cn/interview/vue/observable.html#%E4%B8%89%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" target="_blank" rel="noreferrer">解析参考</a></li></ul>',9),s=[o];function i(u,n,b,v,c,h){return t(),a("div",null,s)}const p=e(l,[["render",i]]);export{d as __pageData,p as default};
