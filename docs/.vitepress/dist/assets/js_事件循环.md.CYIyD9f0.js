import{_ as e,c as t,o as i,a3 as a}from"./chunks/framework.BmlUaO9n.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/事件循环.md","filePath":"js/事件循环.md","lastUpdated":1714909193000}'),l={name:"js/事件循环.md"},s=a('<h2 id="说说对事件循环的理解" tabindex="-1">说说对事件循环的理解 <a class="header-anchor" href="#说说对事件循环的理解" aria-label="Permalink to &quot;说说对事件循环的理解&quot;">​</a></h2><p>JS是一个单线程的脚本语言，同一时间只能做一件事。事件循环可以实现单线程非阻塞,确保JS程序能够处理大量的异步任务并保持程序的响应性</p><p>JS任务：</p><ul><li>同步任务：立刻执行的任务，一般会直接进入主线程执行</li><li>异步任务：异步执行的任务，比如接口请求，定时器等。会进入任务队列。</li></ul><p><em>主线程 执行栈 任务队列 宏任务 微任务</em></p><blockquote><p>主线程里的同步任务执行完毕，会去任务队列读取任务，有任务就推入到主线程执行，如果执行宏任务之前有微任务，那么先执行微任务，这样的过程不断重复就是事件循环，直到所有任务执行完毕</p></blockquote><h3 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h3><p>异步任务分为宏任务和微任务，微任务在宏任务之前执行 <strong>微任务</strong></p><ul><li>Promise.then</li><li>MutationObserver</li><li>Object.observe Proxy</li><li>process.nextTick(Node.js)</li></ul><p>await是返回一个Promise对象，所以await下面的代码会加入微任务队列</p><p><strong>宏任务</strong> 时间粒度较大，执行时间间隔不能精确控制，高实时性需求不太符合</p><ul><li><p>script 外层同步代码</p></li><li><p>setTimeout/setInterval</p></li><li><p>UI rendering</p></li><li><p>postMessage MessageChannel</p></li><li><p>setImmediate I/O (Node.js)</p></li><li><p>执行一个宏任务，如果遇到微任务会将其放到微任务的事件队列里</p></li><li><p>当前宏任务执行完，查看微任务的时间队列，里面所有微任务执行完然后执行下一个宏任务</p></li></ul>',12),o=[s];function r(p,n,_,c,d,u){return i(),t("div",null,o)}const f=e(l,[["render",r]]);export{m as __pageData,f as default};
