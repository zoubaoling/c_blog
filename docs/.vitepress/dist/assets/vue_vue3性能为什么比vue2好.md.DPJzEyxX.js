import{_ as e,c as l,o as t,a3 as i}from"./chunks/framework.B7tteqv2.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue3性能为什么比vue2好.md","filePath":"vue/vue3性能为什么比vue2好.md","lastUpdated":1715657339000}'),u={name:"vue/vue3性能为什么比vue2好.md"},a=i('<h2 id="vue3的性能为什么比vue2好" tabindex="-1">vue3的性能为什么比vue2好？ <a class="header-anchor" href="#vue3的性能为什么比vue2好" aria-label="Permalink to &quot;vue3的性能为什么比vue2好？&quot;">​</a></h2><ul><li>编译阶段 <ul><li>diff算法优化：静态部分编译时会被标记，diff时只会比对非晶态节点，减少了需要进行diff的节点数量，从而提高了性能</li><li>静态提升：静态内容会做静态提升，只会被创建一次，在渲染时直接复用，避免去重复的创建节点，优化了运行时候的内存占用</li><li>事件监听缓存 <ul><li>缓存内联函数，避免每次渲染重新创建。除非依赖的响应式数据变化，否则不会重新创建函数，减少了不必要的内存分配和垃圾回收</li></ul></li></ul></li><li>源码体积 <ul><li>移除了一些不常用的API: filters $destroy EventBus $on/$off/$once Vue.set Vue.delete</li><li>使用tree-shaking, 只打包使用的模块</li></ul></li><li>响应式系统 <ul><li>使用proxy替代defineProxy，可以直接监听整个对象，不用遍历属性</li><li>不会初始时递归遍历属性做响应式处理，只有在实际需要时(getter拦截器中)才将对象的对象属性转换为响应式的，减少不必要的性能开销</li></ul></li></ul>',2),_=[a];function o(r,s,n,d,c,v){return t(),l("div",null,_)}const h=e(u,[["render",o]]);export{p as __pageData,h as default};
