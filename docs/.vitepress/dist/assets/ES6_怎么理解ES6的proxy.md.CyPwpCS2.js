import{_ as e,c as a,o as t,a5 as i}from"./chunks/framework.B102yH4G.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/怎么理解ES6的proxy.md","filePath":"ES6/怎么理解ES6的proxy.md","lastUpdated":1715864760000}'),s={name:"ES6/怎么理解ES6的proxy.md"},r=i(`<h2 id="你是怎么理解es6中proxy的-使用场景有哪些" tabindex="-1">你是怎么理解ES6中Proxy的？使用场景有哪些 <a class="header-anchor" href="#你是怎么理解es6中proxy的-使用场景有哪些" aria-label="Permalink to &quot;你是怎么理解ES6中Proxy的？使用场景有哪些&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p>用于定义基本操作的自定义行为，创建指定对象的代理，实现基本操作的拦截和自定义</p><h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h3><p><code>new Proxy(target: object, handler: object)</code>接收两个参数</p><ul><li>第一个是需要拦截的对象</li><li>第二个是自定义行为handler，一个包含了各种函数属性的对象，定义了个操作的代理行为</li></ul><h4 id="handler支持的拦截属性" tabindex="-1">handler支持的拦截属性 <a class="header-anchor" href="#handler支持的拦截属性" aria-label="Permalink to &quot;handler支持的拦截属性&quot;">​</a></h4><ul><li><code>get(target, propKey, receiver)</code> 拦截属性的读取</li><li><code>set(target, propKey, value, receiver)</code> 拦截属性的设置</li><li><code>deleteProperty(target, propKey)</code> 拦截属性的删除</li><li><code>ownKeys(target)</code> 拦截Object.keys和for in、Object.assign、Object.getOwnPropertyNames、Object.getOwnPropertySymbols等循环，返回一个数组</li><li><code>apply(target, object, arts)</code> 调用一个函数</li><li><code>construct(target, arts)</code> 拦截new调用一个函数</li><li><code>getPrototypeOf(target)</code>：拦截Object.getPrototypeOf(proxy)，返回一个对象</li><li><code>setPrototypeOf(target, proto)</code>：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象</li><li><code>has(target, propKey)</code>, 拦截in操作符</li></ul><p>代理撤销 <code>Proxy.revocable</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revocable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// revoke执行后，proxy不可用</span></span></code></pre></div><p>Reflect拥有proxy支持的代理行为的同名方法，可以改变一些默认行为，比如异常时不是报错，而是返回false</p><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><ul><li>拦截和监听外部对对象的访问</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul>`,13),o=[r];function l(p,n,h,c,d,k){return t(),a("div",null,o)}const E=e(s,[["render",l]]);export{g as __pageData,E as default};
