import{_ as l,c as i,o as a,a3 as e}from"./chunks/framework.B7tteqv2.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"http/常见的攻击方式.md","filePath":"http/常见的攻击方式.md","lastUpdated":1715776730000}'),o={name:"http/常见的攻击方式.md"},t=e('<h2 id="web常见的攻击方式有哪些-以及如何进行防御" tabindex="-1">web常见的攻击方式有哪些，以及如何进行防御？ <a class="header-anchor" href="#web常见的攻击方式有哪些-以及如何进行防御" aria-label="Permalink to &quot;web常见的攻击方式有哪些，以及如何进行防御？&quot;">​</a></h2><ul><li>XSS Cross Site Scripting 跨站脚本攻击 <ul><li>攻击者将恶意代码植入到提供给其他用户使用的页面: 攻击者、客户端、WEB应用</li><li>为了盗取存储在客户端的cookie或者其他用于识别客户端身份的敏感信息。一旦获取合法用户信息，攻击者回假冒合法用户与网站交互</li><li>分类：存储型、反射型、DOM型</li></ul></li><li>CSRF Cross-site-request-forgery 跨站请求伪造 <ul><li>攻击者诱导用户进入第三方网站，在第三方网站发向被攻击网站发送跨站请求</li><li>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</li></ul></li><li>SQL注入攻击 <ul><li>将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击</li></ul></li></ul><h3 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-label="Permalink to &quot;XSS&quot;">​</a></h3><h4 id="存储型" tabindex="-1">存储型 <a class="header-anchor" href="#存储型" aria-label="Permalink to &quot;存储型&quot;">​</a></h4><p>将恶意代码提交到数据库中，然后返回给浏览器解析执行，常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等 存储型 XSS 的攻击步骤：</p><ul><li>攻击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><h4 id="反射型-xss" tabindex="-1">反射型 XSS <a class="header-anchor" href="#反射型-xss" aria-label="Permalink to &quot;反射型 XSS&quot;">​</a></h4><p>用户访问包含恶意代码的URL，服务端将恶意代码从URL中取出并返回给浏览器解析执行，反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等，需要用户主动打开恶意的URL，所以一般会诱导用户点击 反射型 XSS 的攻击步骤：</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><p>POST 的内容也可以触发反射型XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见</p><h4 id="dom型-xss" tabindex="-1">DOM型 XSS <a class="header-anchor" href="#dom型-xss" aria-label="Permalink to &quot;DOM型 XSS&quot;">​</a></h4><p>用户打开包含恶意代码的URL，浏览器解析URL中的恶意代码并执行 DOM 型 XSS 的攻击步骤：</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的URL</li><li>用户浏览器接收到响应后解析执行，前端JS取出URL中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><h4 id="对比" tabindex="-1">对比 <a class="header-anchor" href="#对比" aria-label="Permalink to &quot;对比&quot;">​</a></h4><ul><li>存储型恶意代码存储在数据库中，反射型恶意代码存储在URL中，DOM型是浏览器直接解析执行URL中的恶意代码</li><li>存储型和反射型是服务端的安全漏洞，DOM型是前端的安全漏洞</li><li>使用场景： <ul><li>存储型常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</li><li>反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等，需要用户主动打开恶意的URL，所以一般会诱导用户点击</li></ul></li></ul><h4 id="预防" tabindex="-1">预防 <a class="header-anchor" href="#预防" aria-label="Permalink to &quot;预防&quot;">​</a></h4><p>两大因素：攻击者提交恶意代码、浏览器执行恶意代码</p><p>攻击者提交恶意代码：</p><ol><li>前端过滤输入内容</li><li>服务端写入数据库前进行过滤转义</li></ol><p>浏览器执行恶意代码：</p><ol><li>不要把不可信的数据作为 HTML 插到页面上，减少.innerHTML、.outerHTML、document.write使用，尽量使用.textContent、.setAttribute、.createElement可以自动处理编码</li><li>用户输入内容插入HTML中前，要先进行编码，防止作为代码执行，比如: &lt;(&lt;) &gt;(&gt;) &amp;等</li><li>不使用v-html</li><li>DOM内联事件监听器(location、onclick、onerror、onload、onmouseover等)<code>&lt;a&gt;</code>标签的 href 属性、eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，要避免</li></ol><h3 id="csrf攻击" tabindex="-1">CSRF攻击 <a class="header-anchor" href="#csrf攻击" aria-label="Permalink to &quot;CSRF攻击&quot;">​</a></h3><p><strong>典型流程</strong> 用户登陆网站并通过认证，被诱导访问第三方网站，第三方网站向被攻击网站发送请求并携带认证信息，此请求被误认为是用户发送并执行，在用户不知情的情况下冒充用户让网站执行操作</p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）</li><li>攻击者引诱受害者访问了b.com</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li><li>a.com以受害者的名义执行了act=xx</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li></ul><h4 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h4><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”</li><li>跨站请求方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</li></ul><h4 id="预防-1" tabindex="-1">预防 <a class="header-anchor" href="#预防-1" aria-label="Permalink to &quot;预防&quot;">​</a></h4><p>CSRF通常从第三方网站发起，被攻击的网站<code>无法防止攻击发生</code>，只能通过<code>增强自己网站针对CSRF的防护能力</code>来提升安全性 <strong>方法：</strong></p><ul><li>阻止不明外域的访问: 同源检测 + Samesite Cookie</li><li>提交时要求附加本域才能获取的信息: CSRF Token + 双重Cookie验证 <ul><li>用户访问页面，服务器会生成一个Token,客户端下次发送请求就需要携带Token,服务端判断有效性</li></ul></li></ul><h3 id="sql注入" tabindex="-1">SQL注入 <a class="header-anchor" href="#sql注入" aria-label="Permalink to &quot;SQL注入&quot;">​</a></h3><p>...</p>',31),r=[t];function s(n,c,h,u,d,S){return a(),i("div",null,r)}const _=l(o,[["render",s]]);export{p as __pageData,_ as default};
