import{_ as e,c as i,o,a5 as l}from"./chunks/framework.B102yH4G.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/ES6中的Promise.md","filePath":"ES6/ES6中的Promise.md","lastUpdated":1715864760000}'),r={name:"ES6/ES6中的Promise.md"},t=l('<h2 id="你是怎么理解es6中-promise的-使用场景有哪些" tabindex="-1">你是怎么理解ES6中 Promise的？使用场景有哪些？ <a class="header-anchor" href="#你是怎么理解es6中-promise的-使用场景有哪些" aria-label="Permalink to &quot;你是怎么理解ES6中 Promise的？使用场景有哪些？&quot;">​</a></h2><p>promise是异步编程的一种解决方案，比传统的方式(eg: 回调函数)更加强大、合理, 解决了回调地狱的问题</p><p>相对来说：</p><ul><li>其链式操作降低了编码的难度</li><li>代码可读性和可维护性增强</li></ul><p>Promise有三种状态：<code>pending fulfilled rejected</code></p><p>其状态一旦改变，不会发生变更</p><ul><li>pending &gt; fulfilled</li><li>pending &gt; rejected</li></ul><h3 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法&quot;">​</a></h3><p>Promise对象是一个构造函数，用来生成promise实例，接收两个参数resolve和reject</p><ul><li>resolve将状态由pending &gt; fulfilled</li><li>reject将状态由pending &gt; rejected</li></ul><p><strong>实例方法</strong></p><ul><li><code>then</code> 状态变更时的回调，第一个参数resolve状态的回调函数，第二个参数是reject状态的回调函数。then返回一个新的Promise实例，所以可以链式调用</li><li><code>catch</code> 指定发生错误时的回调 reject状态,promise的错误有冒泡性质，直到被捕获。promise的错误不会传递到外面，只能在内部捕获</li><li><code>finally</code> 不管状态怎么样，最后都会执行的操作</li></ul><p><strong>构造函数方法</strong></p><ul><li><code>Promise.all</code>: 接受一个Promise数组作为参数，数组所有元素都fulfilled,才会返回结果，一旦有一个reject，就会被捕获。如果实例内部有catch，会先被内部捕获</li><li><code>Promise.race</code>: 接受多个Promise实例，最先改变状态的实例的结果和状态会先返回</li><li><code>Promise.allSettled</code>：接受多个Promise实例，等所有实例都返回结果,正常或异常，才会返回 status reason value</li><li><code>Promise.resolve</code>: 返回一个resolve状态的promise对象</li><li><code>Promise.reject</code>：返回一个reject状态的promise对象</li></ul>',14),s=[t];function c(a,d,n,p,m,_){return o(),i("div",null,s)}const h=e(r,[["render",c]]);export{P as __pageData,h as default};
