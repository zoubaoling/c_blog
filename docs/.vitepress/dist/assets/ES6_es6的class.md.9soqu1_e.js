import{_ as e,c as l,o as s,a5 as i}from"./chunks/framework.B102yH4G.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/es6的class.md","filePath":"ES6/es6的class.md","lastUpdated":1715864760000}'),t={name:"ES6/es6的class.md"},o=i('<h2 id="es5-中的类和es6中的class有什么区别" tabindex="-1">es5 中的类和es6中的class有什么区别 <a class="header-anchor" href="#es5-中的类和es6中的class有什么区别" aria-label="Permalink to &quot;es5 中的类和es6中的class有什么区别&quot;">​</a></h2><blockquote><p>es5中主要是通过构造函数和原型来定义一个类，es6中通过class关键字来定义</p></blockquote><h3 id="class类" tabindex="-1">Class类 <a class="header-anchor" href="#class类" aria-label="Permalink to &quot;Class类&quot;">​</a></h3><ol><li>必须用new关键字调用，不能直接执行，ES5本质上和普通函数没什么区别</li><li>不存在变量提升，在声明之前使用会报错, 函数声明会变量提升</li><li>class类无法遍历实例原型链上的属性和方法（constructor之外的），比如用for-in遍历 <ul><li>只有在构造函数里创建的属性是自有属性，不会出现在原型上</li><li>constructor以外的方法是原型上的，等同于<code>ClassName.prototype.func</code></li></ul></li><li>class除constructor外的方法不可以使用new调用</li><li>类中所有代码都在严格模式下执行，且不可修改为非严格模式</li><li>类声明和类表达式 <ul><li><code>class Foo</code>，名称为Foo，不存在变量提升</li><li><code>let Foo2 = class {}</code> <code>let Foo2 = class Foo {}</code>,外部使用的名称为Foo2,Foo只能在类内部使用，外部无法访问。使用<code>let</code>声明不存在变量提升</li><li>立即调用类构造函数<code>new class{}</code></li></ul></li><li>访问器属性getter: get, setter: set <ul><li>可以在原型上定义访问器属性，不可以与其他属性包括自有属性重名</li><li>getter: <code>get name (){}</code></li><li>setter: <code>set name() {}</code>,不要直接修改set后的name，往往是处理类中其他属性并返回</li></ul></li><li>可计算属性名，在[]中使用，和对象类似</li><li>可以在类中添加生成器（* yield）和迭代器（Symbol.iterator）</li><li>静态方法，使用static关键字来修饰方法和属性 <ul><li>静态方法在构造函数上声明，不依赖于实例<code>Person.fun</code>,不是<code>Person.prototype.fun</code></li><li>static不可用于构造函数</li><li>static成员无法被遍历，for-in Object.keys</li><li>静态成员只能通过类名调用ClassName.xx，其他方法this.xx都不可以</li><li>static方法内只能访问static方法和属性(this.xxx, ClassName.xxx都可以)，可以继承父类的静态属性方法</li></ul></li><li>继承，使用<code>extends</code>关键字。继承自其他类的类为派生类，父类为基类 <ul><li>派生类中如果有构造函数，必须执行<code>super()</code>,并传入参数，如果没有构造函数，会默认调用</li><li>super是访问基类的构造函数，super(args)等同于<code>基类.call(this, args)</code></li><li>非派生类不可以使用super</li><li>派生类构造函数使用this之前必须使用super,负责初始化this</li><li>可以通过super调用基类的属性和方法, 派生类同名的属性和方法会覆盖基类，可以用super.xx来调用</li><li>static属性和方法可以被继承，使用派生类名称来调用</li><li>派生类构造函数中<code>this instance 基类｜派生类</code>都为true</li><li>class可以继承具有<code>[[construct]]</code>属性和原型的方法，比如ES5的构造函数</li></ul></li><li>private,<em>TS特有</em> 私有属性，只在类内部使用，子类和实例不可使用</li><li>protected，<em>TS特有</em> 类和子类内部使用，实例不可使用</li><li>public， <em>TS特有</em> 所有地方都可以使用，类内部，子类内部，实例，默认public</li></ol>',4),c=[o];function a(r,d,n,u,p,_){return s(),l("div",null,c)}const x=e(t,[["render",a]]);export{h as __pageData,x as default};
