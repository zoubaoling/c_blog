import{_ as i,c as l,o as e,a3 as t}from"./chunks/framework.BmlUaO9n.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"webpack/vite官网记录.md","filePath":"webpack/vite官网记录.md","lastUpdated":1715657339000}'),o={name:"webpack/vite官网记录.md"},r=t('<ol><li>源码启用协商缓存，依赖启用强缓存</li><li>开发环境esbuild编译，生产环境rollup打包</li><li>vite的插件API与esbuild作为打包器不兼容</li><li>预构建，esbuild将CommonJS/UMD转为ESM,提高加载速度</li><li>重写导入(import)为合法的Url</li><li>vite默认转义(esbuild).ts文件，但是ts转义和ts静态检测是分开的，静态检测需要整个依赖图，会降低速度</li><li>生产：tsc --noEmit; 开发: tsc --noEmit --watch 或 vite-plugin-checker浏览器中查看上报的类型错误</li><li>import.meta.env import.meta.hot</li><li>vite通过postcss-import预内置支持css的@import</li><li>x.module.css是一个css modules文件，返回一个模块对象,可以操作对象</li><li>vite内置了对预处理器的支持，不需要安装插件，但是需要安装预处理器依赖</li><li>import otherStyles from &#39;./bar.css?inline&#39;，添加?inline样式不会注入页面，而是按名导入</li><li>import xx from &#39;xxx?[url, raw, worker, worker&amp;inline]&#39;; url- 解析后的URL，raw- 加载资源的字符串形式内容</li><li>import.meta.glob支持导入到个模块: const modules = import.meta.glob(&#39;./dir/*.vue&#39;), 批量导入dir下的所有vue文件</li></ol><ul><li>eager: import.meta.glob(&#39;&#39;, { eager: true }) 静态导入，默认导入是懒加载：() =&gt; import(XXX) &gt; module1.then()</li><li><code>[&#39;./dir/*.js&#39;, &#39;./dir2/*.js&#39;]</code>: 数组形式支持多个匹配</li><li>{ import: &#39;setup | default&#39;}: 支持加载指定部分内容</li><li><code>&#39;!**/a.js&#39;</code>反向匹配，忽略</li><li><code>{query: &#39;?raw|url&#39;}</code></li><li>所有参数必须是字面量，不可以用变量或表达式</li></ul><ol start="15"><li>字面量动态导入: await import(<code>./dir${file}.js</code>)，变量只支持一层，深层会失败</li><li>node.js中可以通过import导入模块</li><li>vite预置css代码分割功能，除非关闭否则不需要显示配置--将异步chunk模块中的css抽离成一个单独文件，chunk加载完成后通过Link引入，chunk在css加载完成后再执行</li><li>首次执行vite,进行依赖预构建：1. CommonJS和UMD转换ESM 2. 将有许多内部模块的ESM依赖转换为单个模块，比如Lodash内部有几百个内置模块，会发几百个请求，预构建为单个模块，只需要一个请求</li><li>new URL得到完整解析的静态资源URL: <code>new URL(&#39;&#39;, import.meta.url).href</code>,生产构建时URL需要是静态的</li><li>public目录在项目根目录</li></ol><ul><li>不应该被JS文件引用</li><li>必须使用绝对路径(/)引入资源：public/icon.png &gt; /icon.png--</li><li>打包时会被复制到目标目录的根目录下</li><li>不会被源码引用，保持原有文件名，不会被hash,只是想引用URL</li></ul><ol start="21"><li>公共基础路径：import.meta.env.BASE_URL</li><li>build.rollupOptions自定义构建</li><li>external</li><li>环境变量:import.meta.env，构建时被静态替换 import.meta.env.[MODE, BASE_URL, PROD, DEV, SSR]</li><li>.env文件，添加额外的环境变量</li></ol><ul><li>.env.[mode] .env.local .env.[mode].local; .local被Git忽略；.[mode]指定模式加载</li><li>.env[mode] &gt; .env</li><li>VITE_xx开头的变量才能被源码访问到，且会转换为字符串</li></ul><ol start="26"><li>import.meta.env.xxx &gt; html: %MODE% %VITE_API_URL%</li><li>vite默认开发模式，vite build默认生产模式 --mode MODE_ENV=</li></ol>',7),s=[r];function a(m,c,n,d,p,u){return e(),l("div",null,s)}const h=i(o,[["render",a]]);export{_ as __pageData,h as default};
