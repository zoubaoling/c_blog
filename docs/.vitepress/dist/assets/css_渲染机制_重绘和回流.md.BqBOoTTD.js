import{_ as l,c as i,o as t,a3 as a}from"./chunks/framework.B7tteqv2.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"css/渲染机制&重绘和回流.md","filePath":"css/渲染机制&重绘和回流.md","lastUpdated":1714991694000}'),e={name:"css/渲染机制&重绘和回流.md"},o=a('<h2 id="怎么理解回流跟重绘-什么场景下会触发" tabindex="-1">怎么理解回流跟重绘？什么场景下会触发？ <a class="header-anchor" href="#怎么理解回流跟重绘-什么场景下会触发" aria-label="Permalink to &quot;怎么理解回流跟重绘？什么场景下会触发？&quot;">​</a></h2><p>重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小 重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制</p><h3 id="页面渲染机制" tabindex="-1">页面渲染机制 <a class="header-anchor" href="#页面渲染机制" aria-label="Permalink to &quot;页面渲染机制&quot;">​</a></h3><ol><li>解析HTML，生成DOM树；解析CSS，生成CSSOM树</li><li>DOM树和CSS树结合，生成渲染树Render Tree</li><li>Layout:布局/回流，根据生成的渲染树，进行布局，得到节点的几何信息-大小、位置</li><li>Painting:重绘，根据布局得到的几何信息，将节点渲染到屏幕上</li></ol><ul><li>painting得到绝对像素 &gt; display: 将像素发送给GPU，展示在页面</li></ul><p>DOM树和渲染树</p><ul><li>DOM树是和HTML标签一一对应的，包括head和隐藏元素</li><li>渲染树是不包含head和隐藏元素</li></ul><h3 id="触发时机" tabindex="-1">触发时机 <a class="header-anchor" href="#触发时机" aria-label="Permalink to &quot;触发时机&quot;">​</a></h3><p><strong>重排</strong> 对DOM的大小、位置进行修改后，影响了DOM几何尺寸的变化，浏览器需要重新计算元素的这些几何属性，就会触发重排</p><ul><li>添加、删除可见DOM</li><li>修改元素位置</li><li>修改元素尺寸：padding border width height margin</li><li>元素内容发生变化</li><li>页面初始渲染</li><li>浏览器窗口尺寸变化（重排是根据视口的大小来计算元素位置和大小的）</li><li>特殊操作，比如获取特定属性的值，因为需要及时计算，也会重排 <ul><li>offsetTop|Left|Width|Height</li><li>scrollTop|Left|Width|Height</li><li>clientTop|Left|Width|Height</li><li>getComputedStyle 浏览器队列优化策略，一段时间或一个阈值清空队列。但是获取布局信息操作会强制清空，获取最新数据</li></ul></li></ul><p><strong>重绘</strong> 触发重排一定会触发重绘 对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘</p><ul><li>颜色</li><li>文本方向</li><li>阴影</li></ul><h3 id="如何减少" tabindex="-1">如何减少 <a class="header-anchor" href="#如何减少" aria-label="Permalink to &quot;如何减少&quot;">​</a></h3><ul><li>减少DOM操作，可以使用DocumentFragment一次性操作</li><li>避免循环中使用offsetLeft等属性</li><li>可以通过改变class类名来修改元素样式，避免重排</li><li>避免table布局，table中的每个元素大小及内容改动，会影响整个table</li><li>可以使用transform opacity visibility这些属性,替代left display等会触发重排的操作</li><li>DOM离线，设置display:none后在进行操作</li><li>避免设置过多内联样式</li><li>避免使用CSS表达式--表达式计算是实时的，每次渲染都会执行，会频繁重排和重绘</li></ul>',14),r=[o];function s(n,d,c,h,_,p){return t(),i("div",null,r)}const m=l(e,[["render",s]]);export{f as __pageData,m as default};
