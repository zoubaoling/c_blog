import{_ as l,c as i,o as e,a3 as t}from"./chunks/framework.B7tteqv2.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/ES6函数新增扩展.md","filePath":"ES6/ES6函数新增扩展.md","lastUpdated":1714567771000}'),n={name:"ES6/ES6函数新增扩展.md"},a=t('<h2 id="es6函数新增了哪些扩展" tabindex="-1">ES6函数新增了哪些扩展 <a class="header-anchor" href="#es6函数新增了哪些扩展" aria-label="Permalink to &quot;ES6函数新增了哪些扩展&quot;">​</a></h2><ul><li>参数默认值 <ul><li>参数可以设置默认值，参数不传或者传的值为undefined时使用默认值,如果传参为null,取值为null，不会使用默认值</li><li>参数设置默认值后，会影响arguments，和es5严格模式一样，形参和arguments分离，修改参数值后，arguments不会被影响，永远为初始值</li><li>默认参数是在函数调用时求值，后定义的参数可以访问先定义的参数</li><li>函数参数和函数体的作用域是分开的，函数参数不可以访问函数体内的变量</li></ul></li><li>rest参数、不定参数，通过...获取，是一个数组 <ul><li>需要放在参数默认</li><li>一个函数中只能有一个不定参数</li><li>对象字面量的set函数中不可以使用，因为只会有一个参数</li><li>不定参数可以用来替换arguments，但是arguments仍然可以使用</li></ul></li><li>展开运算符，将一个数组打散开成独立的参数传入函数</li><li>name属性，获取函数的名称 <ul><li>函数表达式名称权重最高<code>function funName</code> &gt; funName</li><li>赋值值其他变量，函数表达式有名称为其名称，没有则为变量名称</li><li>Function构造函数函数创建的为anonymous(匿名)</li><li>bind()函数创建的会带有<code>bound </code>前缀</li></ul></li><li>判断函数的用途新增：new.target,只能在函数内使用 <ul><li>函数可作为new构造函数或执行函数使用,原来可以通过this instanceof ContrucName判断（new会创建实例对象，并将this绑定到实例上）</li><li>新增new.target属性，如果普通执行,new.target为undefined，如果通过new执行,返回实例对象也就是构造函数，但是都可能会被call apply bind影响</li></ul></li><li>块级函数，<code>function</code>声明会被提升到作用域顶部，如果使用let声明，不会提升</li><li>箭头函数 <ul><li><p>没有arguments，可以使用rest参数代替</p></li><li><p>this是定义时所在的对象，不是使用时所在的对象，如果被非箭头函数包含，则为最近一层非箭头函数的this，否则是全局对象</p></li><li><p>不能作为构造函数，不能使用new命令</p></li><li><p>没有原型</p></li><li><p>不能改变this指向</p></li><li><p>[] 尾调用优化</p></li></ul></li></ul>',2),s=[a];function o(u,r,c,_,d,p){return e(),i("div",null,s)}const h=l(n,[["render",o]]);export{f as __pageData,h as default};
