import{_ as l,c as i,o as e,a5 as a}from"./chunks/framework.B102yH4G.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"http/TCP三次握手和四次回收.md","filePath":"http/TCP三次握手和四次回收.md","lastUpdated":1716005365000}'),o={name:"http/TCP三次握手和四次回收.md"},t=a('<h2 id="说说tcp为什么需要三次握手和四次挥手" tabindex="-1">说说TCP为什么需要三次握手和四次挥手 <a class="header-anchor" href="#说说tcp为什么需要三次握手和四次挥手" aria-label="Permalink to &quot;说说TCP为什么需要三次握手和四次挥手&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><blockquote><p>客户端和服务器总共发送3个包，主要是为了确认双方接受和发放能力是否正常</p></blockquote><ol><li><code>第一次握手</code>: 客户端给服务器发送一个TCP报文【向服务器请求连接】; 客户端处理SYN-SEND状态 <ul><li>SYN = 1 建立一个新连接</li><li>seq = x 随机序列号</li></ul></li><li><code>第二次握手</code> 服务器接收到 SYN 报文后，回复浏览器 【同意连接】; 服务端进入 SYN-REVD阶段 <ul><li>SYN = 1 同意建立一个新链接</li><li>ACK = 1 确认收到序列号</li><li>seq = y 随机序列号</li><li>ack = x + 1 确认收到序列号是x</li></ul></li><li><code>第三次握手</code> 浏览器收到报文后回复服务器 【收到回复】; 双方连接已建立，开始传送数据 <ul><li>ACK = 1 确认收到序列号</li><li>seq = x + 1 上一次浏览器发送的 seq = x 基础上 + 1</li><li>ack = y + 1 确认收到的序列号是服务器回复的 y</li><li>服务器和浏览器同时进入 ESTABLISHED 状态</li></ul></li></ol><h4 id="为什么不是两次握手" tabindex="-1">为什么不是两次握手 <a class="header-anchor" href="#为什么不是两次握手" aria-label="Permalink to &quot;为什么不是两次握手&quot;">​</a></h4><p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到，无法确定自己发的包对方能收到</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>刚开始双方都处于 ESTABLISHED 状态</p><ol><li><code>第一次挥手</code> 向服务器发送报文; 浏览器进入 FIN-WAIT-1 半关闭阶段 <ul><li>FIN = 1 关闭连接</li><li>seq = u 随机序列号</li></ul></li><li><code>第二次挥手</code> 服务器收到报文后，回复豹纹表示收到客户端的报文了； 服务器进入 COLSE-WAIT 处理阶段, 浏览器进入 FIN-WAIT-2 阶段 等待服务器处理 <ul><li>ACK = 1 确认收到序列号</li><li>ack = u + 1 确认收到序列号为 u</li><li>seq = v 随机序列号</li></ul></li><li><code>第三次挥手</code> 服务器也要断开连接，发送FIN报文给浏览器; 服务器进入 LAST-ACK 阶段 等待浏览器确认收到 <ul><li>FIN = 1 关闭连接</li><li>ACK = 1 确认收到序列号</li><li>ack = u + 1 确认收到序列号为u</li><li>seq = w 随机序列号</li></ul></li><li><code>第四次挥手</code> 浏览器收到服务器报文，回复服务器; 浏览器进入 TIME-WAIT 阶段，此时TCP未释放掉，等待 2MSL(毫秒)，等待服务器收到自己的报文，然后进入 COLSE 阶段 <ul><li>ACK = 1 确认收到序列号</li><li>seq = u + 1 上一次浏览器发送的 seq = u 基础上 + 1</li><li>ack = w + 1 确认收到序列号为 w</li></ul></li></ol><h4 id="四次挥手的原因" tabindex="-1">四次挥手的原因 <a class="header-anchor" href="#四次挥手的原因" aria-label="Permalink to &quot;四次挥手的原因&quot;">​</a></h4><p>客户端发送FIN报文后，表示客户端当前没有数据需要处理，而不代表服务端没有数据需要处理。此时需要服务端回复ACK确认收到报文后，开始处理内部数据。当内部数据处理完后，再回复FIN可以关闭连接</p><h3 id="报文字段含义" tabindex="-1">报文字段含义 <a class="header-anchor" href="#报文字段含义" aria-label="Permalink to &quot;报文字段含义&quot;">​</a></h3><ul><li><code>SYN</code> 建立新连接--握手阶段</li><li>seq 序列号，客户端二次发送需要是第一次+1，服务端随机</li><li>ACK = 1 确认收到序列号</li><li>ack = seq + 1 收到的序列号+1，确认收到的序列号</li><li><code>FIN</code> = 1 关闭链接--关闭阶段</li></ul><div class="info custom-block"><p class="custom-block-title">报文流程</p><p>握手：SYN + seq[x] &gt; SYN + ACK + seq[y] + ack[x+1] &gt; ACK + seq[x+1] + ack[y+1]</p><p>关闭：FIN + seq[u] &gt; ACK + seq[v] + ack[u+1] &gt; FIN + ACK + seq[w] + ack[u+1] &gt; ACK + seq[u+1] + ack[w+1]</p></div>',14),c=[t];function s(d,r,u,h,n,_){return e(),i("div",null,c)}const C=l(o,[["render",s]]);export{p as __pageData,C as default};
