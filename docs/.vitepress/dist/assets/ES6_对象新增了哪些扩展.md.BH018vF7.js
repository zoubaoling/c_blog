import{_ as t,c as e,o as d,a3 as o}from"./chunks/framework.BmlUaO9n.js";const O=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/对象新增了哪些扩展.md","filePath":"ES6/对象新增了哪些扩展.md","lastUpdated":1714567771000}'),c={name:"ES6/对象新增了哪些扩展.md"},l=o('<h2 id="对象新增了哪些扩展" tabindex="-1">对象新增了哪些扩展 <a class="header-anchor" href="#对象新增了哪些扩展" aria-label="Permalink to &quot;对象新增了哪些扩展&quot;">​</a></h2><ul><li>属性的简写，键名和值名相等时，可以简写<code>{ name }</code>,方法也可以简写，省略冒号和function关键字<code>{ foo () {} }</code>,简写的对象方法不能用作构造函数</li><li>可计算的属性名（属性名表达式）,在括号内计算<code>{[name]: &#39;pig&#39;}</code>,也可以作为方法名，但是不能和属性简写同时使用，会报错<code>{[name]}</code><ul><li>属性名表达式如果是一个对象，会自动转为字符串<code>[object Object]</code>，对象属性只能为字符串或者symbol</li></ul></li><li>新增的方法： <ul><li>Object.is: 类似于===,除了两种情况<code>Object.is(NaN, NaN)</code>为true, <code>Object.is(-0, +0)</code>为false</li><li>Object.assign: 将一个或多个源对象的属性或方法复制到目标对象上，第一个参数为目标对象。是浅拷贝，如果属性值是对象，拷贝的是对象的引用地址, 对象属性里面内容的修改会相互影响</li><li><code>Object.setPrototypeOf</code>: 修改对象的原型</li><li><code>Object.keys</code> <code>Object.entries</code> <code>Object.values</code>遍历自身，不含继承的，可枚举的数据（不含Symbol）</li><li><code>Object.fromEntries</code> 将键值对数组转换为对象</li><li><code>Object.getOwnPropertyDescriptors</code>获取自身属性的描述对象</li></ul></li><li>自身属性的枚举顺序，影响到：<code>Object.getOwnPropertyNames</code>和<code>Reflect.ownKeys</code><ul><li>排列规则：1. 首先遍历所有数值键，按数值升序排列({2: 2, &#39;3&#39;: 4, [&#39;5&#39;]: 5}都算)；2. 遍历字符串键，按照加入时间生序排列；3. 遍历所有symBol键，按加入时间生序排列</li><li><code>Object.getOwnPropertyNames</code>遍历自身，不包括继承的，不包括symbol的所有属性（枚举和不可枚举）</li><li><code>Reflect.ownKeys</code>遍历自身，不包括继承的，包括symbol的所有属性（枚举和不可枚举）</li><li>for/in 和 Object.keys JSON.stringify相同的规则，不明确</li></ul></li><li>属性的遍历 <table><thead><tr><th>方法</th><th>包括继承</th><th>枚举</th><th>包括symbol属性</th></tr></thead><tbody><tr><td>Object.keys</td><td>不继承</td><td>只可枚举</td><td>不含Symbol</td></tr><tr><td>for/in</td><td>自身 + 继承</td><td>只可枚举</td><td>不含Symbol</td></tr><tr><td>Object.getOwnPropertySymbols</td><td>不继承</td><td>-</td><td>只有Symbol</td></tr><tr><td>Object.getOwnPropertyNames</td><td>不继承</td><td>枚举 + 不可枚举</td><td>不含Symbol</td></tr><tr><td>Reflect.ownKeys</td><td>不继承</td><td>枚举 + 不可枚举</td><td>包括Symbol</td></tr></tbody></table></li><li>扩展运算符，解构赋值中读取剩余参数分配到指定对象，浅拷贝，等同于Object.assign</li><li>super关键字，当前对象的原型对象</li></ul>',2),i=[l];function r(s,a,n,b,_,m){return d(),e("div",null,i)}const h=t(c,[["render",r]]);export{O as __pageData,h as default};
