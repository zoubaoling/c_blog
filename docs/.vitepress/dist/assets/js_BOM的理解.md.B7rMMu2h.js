import{_ as i,c as l,o as t,a3 as e}from"./chunks/framework.COm4hYgr.js";const w=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/BOM的理解.md","filePath":"js/BOM的理解.md","lastUpdated":1714909193000}'),o={name:"js/BOM的理解.md"},a=e('<h2 id="说说你对bom的理解-常见的bom对象你了解哪些" tabindex="-1">说说你对BOM的理解，常见的BOM对象你了解哪些 <a class="header-anchor" href="#说说你对bom的理解-常见的bom对象你了解哪些" aria-label="Permalink to &quot;说说你对BOM的理解，常见的BOM对象你了解哪些&quot;">​</a></h2><h3 id="bom" tabindex="-1">BOM <a class="header-anchor" href="#bom" aria-label="Permalink to &quot;BOM&quot;">​</a></h3><p>浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象，和浏览器做一些交互效果，比如：</p><ul><li>页面的后退、前进、刷新</li><li>浏览器窗口发生变化</li><li>滚动条的滚动</li><li>获取客户的信息：浏览器版本，屏幕分辨率等</li></ul><p>window location history navigator screen</p><p>浏览器的全部内容可以看作DOM，整个浏览器可以看作BOM</p><table><thead><tr><th>DOM</th><th>BOM</th></tr></thead><tbody><tr><td>文档对象模型</td><td>浏览器对象模型</td></tr><tr><td>把<em>文档</em>当作一个对象</td><td>把<em>浏览器</em>当作一个对象</td></tr><tr><td>顶级对象是document</td><td>顶级对象是window</td></tr><tr><td>操作页面元素</td><td>浏览器窗口交互</td></tr><tr><td>W3C标准规范</td><td>浏览器厂商个字浏览器上定义，兼容性差</td></tr></tbody></table><h3 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h3><ul><li>window: 是浏览器窗口，也是JS的全局对象，控制浏览器窗口的各个方面：定时器、对话框、页面导航等 <ul><li>moveBy(x, y): 窗口从当前位置水平移动窗口x像素，垂直移动y像素，x负数向左，y负数向上</li><li>moveTo(x, y): 移动窗体左上角到相对屏幕左上角的(x,y)</li><li>resizeBy(w, h) resizeTo(w, h)</li><li>scrollTo(x, y) scrollBy(x, y)</li><li>window.open(url, windowName, str, bool): 导航特定URL并打开新窗口 <ul><li>str: 一个特性字符串，主要是配置新窗口或者新标签页的浏览器特性，比如工具栏、窗台栏等等</li><li>bool：是否打开新窗口</li></ul></li><li>window.close: 关闭通过window.open打开的窗口</li><li>窗口到屏幕的距离：screenLeft-窗口距离屏幕左侧的距离；screenTop-窗口距离屏幕顶部的距离</li><li>窗口大小 <ul><li>innerHeight|innerWidth-浏览器可视窗口的大小(不包括顶部菜单、开发工具等，纯文档内容大小)</li><li>outerHeight|outerWidth-浏览器窗口的大小,包括顶部菜单、开发工具等</li><li>可视窗口实际开发时使用: document.documentElement.clientWidth | clientHeight</li></ul></li><li>window.screenX | window.screenY: 窗口左上角的坐标，窗口左上角到屏幕的位置，同availLeft考虑双屏，以主屏为基准，减去系统工具栏和菜单等宽高</li><li>setTimeout setInterval</li><li>window.alert window.confirm window.prompt</li><li>document.cookie 读写</li></ul></li><li>location: 地址栏URL相关信息 <ul><li>location.reload: 重新刷新页面。如果页面自上一次请求来没有改变，就会从缓存里重新加载。参数传true，可以强制从服务器中重新加载</li><li>location.replace: 导航到传入URL，被替换的会从历史记录中删除</li><li>除了hash以外的属性，只要修改一个，页面就会重新加载</li><li>属性： <ul><li>hash: #contents，#及后面的字符，没有返回空</li><li>host: www.baidu.com:80, 服务器 + 端口</li><li>hostname: www.baidu.com, 域名，不带端口号</li><li>port: 端口号</li><li>protocol: https:, 协议</li><li>href: httpxxxxx#xx，完整的URL</li><li>pathname: /rights/add, 服务器下面的文件路径，host之后查询？之前</li><li>search: ?q=js&amp;b=js,查询字符串，？及之后的部分</li></ul></li></ul></li><li>navigator: 浏览器相关信息, 区分浏览器类型，属性较多，兼容性复杂 <ul><li>language languages platform cookieEnabled</li><li>vendor: 浏览器厂商名称;vendorSub: 浏览器厂商的更多信息</li><li>appName: 浏览器全名;appVersion: 浏览器版本，通常与实际不一致</li></ul></li><li>screen: 屏幕信息 <ul><li>availHeight: 只读，可用高度，屏幕像素高度减去系统组件(菜单、工具栏)高度</li><li>availWidth: 只读,可用宽度，屏幕像素宽度减去系统组件(菜单、工具栏)宽度</li><li>width: <strong>屏幕</strong>像素宽度,与浏览器窗口大小无关</li><li>height: <strong>屏幕</strong>像素高度,与浏览器窗口大小无关</li><li>availLeft: 只读，没有被系统组件占用的屏幕的最左侧像素，减去菜单、工具栏等 <ul><li>如果存在双屏，以主屏为准，副屏的left为其左侧+/-偏离主屏左侧的水平距离</li></ul></li><li>availTop: 只读，没有被系统组件占用的屏幕的最顶端像素，减去菜单工具栏等 <ul><li>如果存在双屏，以主屏为准，副屏的top为其顶部+/-偏离主屏顶部的垂直距离</li></ul></li></ul></li><li>history: 浏览器历史记录，可以通过参数向前、向后，或者指定URL跳转 <ul><li>history.go: 整数数字或者字符串;字符：向最新的一个包含指定字符的记录页面跳转；数字：正数向前，负数向后 跳转N个记录</li><li>history.forward: 向前跳转一个页面</li><li>history.back: 向后跳转一个页面</li><li>history.length: 获取历史记录数量，chrome最大50</li><li>history.pushState(object, title, url) object为随着状态保存的一个对象，title为新页面的标题，url为新的网址 <ul><li>只能同源间跳转</li><li>不会触发hashchange</li></ul></li><li>replaceState(object, title, url) 与pushState的唯一区别在于该方法是替换掉history栈顶元素</li><li>history.state 返回在history栈顶的任意值的拷贝。通过这种方式可以查看state值</li></ul></li></ul><h3 id="clientwidth-vs-offsetwidth" tabindex="-1">clientWidth VS offsetWidth <a class="header-anchor" href="#clientwidth-vs-offsetwidth" aria-label="Permalink to &quot;clientWidth VS offsetWidth&quot;">​</a></h3><ul><li>clientWidth 可视内容大小，不包括padding border scrollbars，纯内容大小</li><li>offsetWidth 内容大小，包括padding border scrollbars</li></ul>',11),r=[a];function d(n,s,h,c,u,m){return t(),l("div",null,r)}const b=i(o,[["render",d]]);export{w as __pageData,b as default};
