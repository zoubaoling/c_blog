## 说说TCP为什么需要三次握手和四次挥手

### 三次握手
> 客户端和服务器总共发送3个包，主要是为了确认双方接受和发放能力是否正常

1. `第一次握手`: 客户端给服务器发送一个TCP报文【向服务器请求连接】; 客户端处理SYN-SEND状态
     - SYN = 1 建立一个新连接
     - seq = x 随机序列号
2. `第二次握手` 服务器接收到 SYN 报文后，回复浏览器 【同意连接】; 服务端进入 SYN-REVD阶段
     - SYN = 1 同意建立一个新链接
     - ACK = 1 确认收到序列号
     - seq = y 随机序列号
     - ack = x + 1 确认收到序列号是x
3. `第三次握手` 浏览器收到报文后回复服务器 【收到回复】; 双方连接已建立，开始传送数据
     - ACK = 1  确认收到序列号
     - seq = x + 1 上一次浏览器发送的 seq = x 基础上 + 1
     - ack = y + 1 确认收到的序列号是服务器回复的 y
     - 服务器和浏览器同时进入 ESTABLISHED 状态

#### 为什么不是两次握手
如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到，无法确定自己发的包对方能收到

### 四次挥手
刚开始双方都处于 ESTABLISHED 状态

1. `第一次挥手` 向服务器发送报文; 浏览器进入 FIN-WAIT-1 半关闭阶段
     - FIN = 1 关闭连接
     - seq = u 随机序列号
2. `第二次挥手` 服务器收到报文后，回复豹纹表示收到客户端的报文了； 服务器进入 COLSE-WAIT 处理阶段, 浏览器进入 FIN-WAIT-2 阶段 等待服务器处理
     - ACK = 1 确认收到序列号
     - ack = u + 1 确认收到序列号为 u
     - seq = v 随机序列号
3. `第三次挥手` 服务器也要断开连接，发送FIN报文给浏览器; 服务器进入 LAST-ACK 阶段 等待浏览器确认收到
     - FIN = 1 关闭连接
     - ACK = 1 确认收到序列号
     - ack = u + 1 确认收到序列号为u
     - seq = w 随机序列号
4. `第四次挥手` 浏览器收到服务器报文，回复服务器; 浏览器进入 TIME-WAIT 阶段，此时TCP未释放掉，等待 2MSL(毫秒)，等待服务器收到自己的报文，然后进入 COLSE 阶段
     - ACK = 1 确认收到序列号
     - seq = u + 1 上一次浏览器发送的 seq = u 基础上 + 1
     - ack  = w + 1 确认收到序列号为 w

#### 四次挥手的原因
客户端发送FIN报文后，表示客户端当前没有数据需要处理，而不代表服务端没有数据需要处理。此时需要服务端回复ACK确认收到报文后，开始处理内部数据。当内部数据处理完后，再回复FIN可以关闭连接


### 报文字段含义
- `SYN` 建立新连接--握手阶段
- seq 序列号，客户端二次发送需要是第一次+1，服务端随机
- ACK = 1 确认收到序列号
- ack = seq + 1 收到的序列号+1，确认收到的序列号
- `FIN` = 1 关闭链接--关闭阶段

:::info 报文流程
握手：SYN + seq[x] > SYN + ACK + seq[y] + ack[x+1] > ACK + seq[x+1] + ack[y+1]

关闭：FIN + seq[u] > ACK + seq[v] + ack[u+1] > FIN + ACK + seq[w] + ack[u+1] > ACK + seq[u+1] + ack[w+1]
:::