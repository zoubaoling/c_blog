## 说说对事件循环的理解

> JS 单线程，事件循环是让它“看起来”同时处理同步与异步任务的调度机制。

### 快速回答结构
1. 先说明 JS 单线程 + 任务分层（同步/异步）。
2. 再讲事件循环核心流程：宏任务 → 微任务 → 渲染 → 下一轮。
3. 补充常见 API 属于哪一类，并点出浏览器与 Node 差异。

### 核心概念
- **同步任务（调用栈）**  
  所有 JS 代码先进入调用栈顺序执行；栈为空时才会处理异步结果。
- **宏任务队列（Task Queue）**  
  按 FIFO 存放定时器、网络回调等大颗粒任务：`script`、`setTimeout`、`setInterval`、`postMessage`、`MessageChannel`、I/O、`setImmediate(Node)`。
- **微任务队列（Microtask Queue / Job Queue）**  
  粒度更细，优先级高于宏任务：`Promise.then/catch/finally`、`queueMicrotask`、`MutationObserver`、`process.nextTick(Node)`。
- **渲染阶段**  
  浏览器在宏任务和微任务全部处理完后才有机会刷新 UI；同步/微任务过多都会阻塞渲染。

速记图：  
`调用栈 (同步)` → `宏任务队列` ↔ `事件循环协调` ↔ `微任务队列` → `渲染`

### 事件循环流程
1. **执行同步代码**：当前宏任务开始时先运行调用栈中的同步逻辑。
2. **产生异步回调**：同步执行过程中注册的异步任务被放入相应队列（宏/微）。
3. **清空微任务队列**：当前宏任务结束后，事件循环会反复取出并执行所有微任务。
4. **渲染检查**：在微任务全部完成后，浏览器可能执行一次渲染。
5. **进入下一个宏任务**：从宏任务队列取出下一个任务，回到步骤 1。

> 面试关键词：**“先宏后微，微任务必须清空”**。

### 示例题（输出顺序）
```js
console.log(1);
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
console.log(4);
```
执行顺序：`1` → `4`（同步） → `3`（微任务） → `2`（宏任务）。答题时记得解释每一步归属。

### async/await 如何参与
- `await` 会把后续代码放入微任务队列，本质是 `Promise`。
- `async` 函数返回值始终是 `Promise`，`await` 前的同步代码仍在当前宏任务内执行。

### 浏览器 vs Node.js
- 浏览器只有一个事件循环，微任务在每轮宏任务后一次性清空。
- Node.js 每个 Phase（Timers、I/O callbacks、Check 等）内都有自己的队列，`process.nextTick` 在 Node 中优先级最高，甚至高于其他微任务，容易导致饥饿。

### 常见面试追问
- 如何解释“宏任务阻塞渲染”：长时间同步或微任务队列过长都会卡 UI。
- 为什么推荐 `queueMicrotask`：显式创建微任务，常用于在事件循环尾部校正状态。
- 如何排查事件循环问题：Chrome Performance 面板、Node `--trace-event`、利用 `setTimeout` 切片长任务。
