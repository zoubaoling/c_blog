## 说说JS内存泄漏的几种情况
### 解释
JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况

### 垃圾回收机制
JS有自动垃圾回收机制(GC: Garbage Collecation)
  - 执行环境会负责管理代码执行过程中使用的内存
  - 垃圾收集器会定期-周期性找出不在继续使用的变量，然后释放内存

**分类**
1. 引用计数
2. 标记清除 - JS最常用的回收机制

#### 标记清除
变量进入执行环境就标记为“进入环境”，进入环境的变量内存无法释放，变量离开环境时，标记为离开环境
垃圾回收机制运行时，会标记内存中所有存储的变量，将存在于上下文中的变量，以及被上下文中变量引用的变量的标记清除掉
剩下的有标记的变量就是需要删除的，上下文的变量没有访问到
随后垃圾回收程序做一次内存管理，销毁带标记的变量及其内存

#### 引用计数
JS维护一张表，记录所有值的引用次数，当一个值的引用次数为0的时候，就表示其没有被引用，可以释放内存
如果一个值没有被使用，但是引用次数不为0，垃圾回收机制就无法回收这块内存，可能造成内存泄漏，可以赋值为null，释放内存

### 常见泄漏的情况
- 全局变量过多，通常是变量未定义或者胡乱引用了全局变量
- 未清除的定时器
- 事件监听未移出
- 一些引用元素没有清除，比如对DOM元素的引用
- 过度的闭包，局部变量无法释放。可以将闭包返回的函数设置为null,手动解除引用

### 如何检查JS中的内存泄漏
[参考文章](https://zhuanlan.zhihu.com/p/322356761)
chrome开发工具的performance和memory
1. performance
- 勾选memory字段，点击录制，正常操作，然后停止
- 录制结束后，如果内存曲线不断升高，就可能内存泄漏了，就可以结合Memory面板进一步定位

2. memory
- 点击左侧原点记录当前堆内存快照(heat snapshot)
- 操作可能发生泄漏的操作，再记录
- 重复操作，再记录多个快照
- 顶部all objects切换Object allcated between,比对新生成的对象，以及retaining tree中没释放的对象

shallow size:对象本身大小
retained size: 对象回收后释放的内存大小
retained size > shallow size需要注意

当生成多个快照后，可以切换到Comparison视图比对两份快照差异：
- 新创建的堆笑
- 销毁的对象
- 差值
- 。。。

- [ ] 学习内存泄漏的检查