## 说说JS内存泄漏的几种情况
### 解释
JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况

### 垃圾回收机制
JS有自动垃圾回收机制(GC: Garbage Collecation)
  - 执行环境会负责管理代码执行过程中使用的内存
  - 垃圾收集器会定期-周期性找出不再继续使用的变量，然后释放内存

#### 分类
1. 引用计数
2. 标记清除 - JS最常用的回收机制

#### 标记清除
变量进入执行环境就标记为“进入环境”，进入环境的变量内存无法释放，变量离开环境时，标记为离开环境

垃圾回收机制运行时，会标记内存中所有存储的变量，将存在于上下文中的变量，以及被上下文中变量引用的变量的标记清除掉

剩下的有标记的变量就是需要删除的，上下文的变量没有访问到

随后垃圾回收程序做一次内存管理，销毁带标记的变量及其内存

#### 引用计数
JS维护一张表，记录所有值的引用次数，当一个值的引用次数为0的时候，就表示其没有被引用，可以释放内存

如果一个值没有被使用，但是引用次数不为0，垃圾回收机制就无法回收这块内存，可能造成内存泄漏，可以赋值为null，释放内存

### 常见泄漏的情况
- 全局变量过多，通常是变量未定义或者胡乱引用了全局变量(全局变量在整个运行期间都是可访问的，始终存在于内存中)
- 未清除的定时器，不清楚的话不再需要的对象和函数仍然会被引用
- 事件监听未移除
  - DOM绑定事件时，如果没有做移除处理，浏览器会保持对该DOM元素和相关函数的引用，导致内存无法释放
- 一些引用元素没有清除，比如对DOM元素的引用（DOM元素即使被移除，也仍然被引用，可以赋值为null解除引用）
- 过度的闭包，局部变量无法释放。可以将闭包返回的函数设置为null,手动解除引用
- 对象之间相互引用

### 预防内存泄露
1. 避免全局变量：使用局部变量和模块化代码，避免创建不必要的全局变量。
2. 移除事件监听器：确保在不再需要时，移除所有的事件监听器。
3. 清除定时器：定时器结束后及时清除，避免占用内存。
4. 解除 DOM 引用：移除 DOM 元素后，确保及时解除对它们的引用。
5. 使用工具监控内存：定期检查代码和性能，利用开发者工具检测和分析内存使用情况。

### 如何检查JS中的内存泄漏
[参考文章](https://zhuanlan.zhihu.com/p/322356761)

chrome开发工具的performance和memory
1. performance
- 勾选memory字段，点击录制，正常操作，然后停止
- 录制结束后，如果内存曲线不断升高，就可能内存泄漏了，就可以结合Memory面板进一步定位

2. memory
- 点击左侧原点记录当前堆内存快照(heat snapshot)
- 操作可能发生泄漏的操作，再记录
- 重复操作，再记录多个快照
- 顶部all objects切换Object allcated between,比对新生成的对象，以及retaining tree中没释放的对象

#### memory面板参数
shallow size:对象本身大小

retained size: 对象回收后释放的内存大小

retained size > shallow size需要注意

当生成多个快照后，可以切换到Comparison视图比对两份快照差异：
- 新创建的对象
- 销毁的对象
- 差值
- ...
