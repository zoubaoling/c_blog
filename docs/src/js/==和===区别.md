## `==` vs `===` vs `Object.is`

> 面试重点：是否发生类型转换、特殊值比较、推荐用法。

### 核心区别
- **`==`（抽象相等）**：类型不同会触发隐式转换，再做比较；存在一套 ECMAScript 抽象相等算法。
- **`===`（严格相等）**：不做转换，类型不同直接 `false`，本质比较“类型 + 值”。
- **`Object.is`**：行为几乎等同 `===`，但把 `NaN` 视为相等，把 `+0` 和 `-0` 视为不同。

### `==` 的隐式转换规则速览
1. **原始类型**：`'1' == true` → `'1'` 转数字 1，`true` 转数字 1，结果 `true`。字符串、布尔值都会先转数字。
2. **对象 vs 原始值**：对象通过 `ToPrimitive` 变原始值。默认顺序：`valueOf()` → `toString()`。
   - 数组示例：`[1,2] == '1,2'` ✓；`[1] == 1` ✓。
3. **对象 vs 对象**：比较引用，地址相同才相等。
4. **`null` 与 `undefined`**：`null == undefined` ✓，且不会触发进一步转换；与其他值比较一律 `false`。
5. **`NaN` 特例**：参与 `==` 或 `===` 时都返回 `false`。

> `Date` 对象的 `ToPrimitive` 会优先走 `toString()`，记得提到这一特殊点。

### `===` / `Object.is` 的语义
- `===`：返回 `true` 需“类型一致且值相等”；`NaN === NaN` 为 `false`。
- `Object.is(a, b)`：
  - `Object.is(NaN, NaN)` → `true`；
  - `Object.is(+0, -0)` → `false`；
  - 其他情况与 `===` 一致。

### 面试答题建议
1. **先表态**：“大多数场景用 `===`，避免隐式转换带来的惊喜。”
2. **再谈例外**：需要兼容 `null | undefined` 时可以用 `== null` 做合并判断。
3. **补充细节**：提一句 `Object.is` 的两个特例，以及 `ToPrimitive` 的转换顺序。

```js
const obj = {}

// 判空写法（只处理 null 或 undefined）
if (obj.name == null) {
  // 等价于 obj.name === null || obj.name === undefined
}
```

- 若要判断 NaN：用 `Number.isNaN()` 或 `Object.is(value, NaN)`。
- 若关心符号位（+0 / -0），可直接用 `Object.is`。