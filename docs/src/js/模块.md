## 说说模块
模块是一种将代码分割成独立功能块的机制，每个模块有自己的变量、方法，在模块内部定义且私有。如果另一个模块中使用，显示的导入和导出
**特点：**
- 命名空间：提供了自己的命名空间，避免了全局命名冲突
- 可维护性：将功能分割成独立的模块，提高了代码的可维护性
- 可重用性：模块可以被不同的程序重用
- 依赖管理：模块使得管理和声明代码之间的依赖关系变得简单

CommonJS → AMD → CMD → ES Module

### CommonJS
CommonJS: 主要用 Node.js，使用 module.exports 和 require 使用（module.exports = {} module.exports.xx = xx）

- 导出的是值的拷贝，一旦导出了某个值，即使模块内数据变化，也不会影响这个值（基本类型不会影响，但是引用对象改变的话还是会相应的发生变化）
- 同步的方式加载模块，require 执行完后（模块的内容加载执行完毕），才能执行后面的代码
- 运行时加载，运行时确定模块的依赖关系。运行时加载，模块的加载、解析和执行都是运行时进行的
- 运行完成后缓存（赋值到 module.exports），其他地方多次导入，也只加载一次。
- module.expots VS exports
  - 每一个文件是一个模块，每一个模块有一个 module对象(exports id filename paths parent..)，对象的 exports 用来导出接口
  - 模块初始化时，module.exports 和 exports 指向同一个内存，exports 被重新赋值（exports = {a, b})，就切断了与原内存地址的关系，所以 module.exports 为{}
  - 所以 exports 需要用.来给属性赋值，不能直接复制修改了指向的内存
  - module.exports 可以直接赋值或者.运算符。模块引入的是 module.exports 的内容

### AMD
AMD(Asynchronous Module Definition):异步模块定义(define([], cb), require([], cb))-依赖前置

- 模块异步加载，require([xx], callback)先加载数组中的模块，加载完再执行需要使用依赖的回调函数（提前加载所有依赖，依赖前置）。不会影响 require 后面的代码的执行
- 适用于浏览器
- 依赖前置，浪费资源，预加载了所有依赖
- 运行时加载，模块的加载、解析和执行都是运行时进行的

### CMD
CMD：define + require，不需要在 require 中先用数组加载所有模块，直接在需要的地方 require 加载，实现按需加载-依赖就近

- 异步加载
- 和 AMD 差不多，只是依赖就近
- 适用于浏览器
- 运行时加载, 模块的加载、解析和执行都是运行时进行的

### UMD
UMD：帮忙判断是使用 AMD 还是 CMD 来定义模块

### ES Module
ES Module：浏览器，import from 和 export{} export default 使用

- 导出的是值的引用，模块内部成员发生改变，引用该模块的地方都会发生改变（不允许直接修改导入的变量）。脚本执行时，根据引用去加载的模块里取值
- 静态编译，编译时处理模块的依赖关系（import()是运行时加载）
- 自动采用严格模式，import 属性只读，不能赋值，类似 const
- export import提升到模块顶级
- ES6模块不是对象， import 会被 JS 引擎静态分析，编译时引入模块代码，而不是在运行时加载
  
*tips:*
  如果想要在HTML中使用使用ES Module的话，需要为`<script>`标签添加一个`type="module"`的属性，然后就可以执行其中的JS代码。
  ES Module有主要以下几个特性：
  - 自动全部采用严格模式，自动忽略`'use strict'`
  - 每个ES Module都会运行的单独的私有作用域中
  - ES Module是通过CORS的方式请求外部JavaScript模块的
  - ES Module的`<script>`标签会自动延迟执行脚本，相当于加了`defer`属性，网页对默认的`<script>`标签采用的是立即执行的机制，页面的渲染会等待这个脚本执行完成才会往下渲染
      

> CommonJS 模块输出的是值的拷贝，是运行时加载，同步加载；ES6模块输出的是值的引用，是编译时输出接口

> 静态加载（编译时加载）:模块的导入导出在编译时处理；运行时加载：模块的加载、解析、执行都在代码运行时

[前端模块化——彻底搞懂AMD、CMD、ESM和CommonJS - 奔跑的瓜牛 - 博客园](https://www.cnblogs.com/chenwenhao/p/12153332.html)