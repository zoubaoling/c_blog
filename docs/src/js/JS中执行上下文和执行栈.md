## JavaScript 中执行上下文和执行栈是什么？

> 执行上下文负责“我在哪运行”；执行栈负责“按什么顺序运行”。

### 执行上下文（Execution Context）
- **定义**：JS 代码在运行时所处的环境，决定了变量访问、`this` 指向、作用域链。
- **类型**
  - 全局执行上下文：整个程序只有一个，浏览器中对应 `window`，Node 中是 `globalThis`。
  - 函数执行上下文：每次函数调用都会创建新的上下文，拥有自己的作用域和 `arguments`。
  - `eval` 执行上下文：由 `eval` 产生，实际开发极少使用。

### 生命周期三阶段
1. **创建阶段**（函数刚被调用但未执行）
   - 确定 `this` 指向（运行时绑定）。
   - 建立词法环境（Lexical Environment）：包含环境记录（变量、函数声明）和外部引用。
   - 建立变量环境（Variable Environment）：用于处理 `var` 声明。
2. **执行阶段**
   - 逐行执行代码，完成变量赋值、函数调用等逻辑，动态更新环境记录。
3. **回收阶段**
   - 当函数执行结束，当前上下文从执行栈弹出，等待垃圾回收器释放资源。

补充：
- 全局上下文的词法环境没有外部引用，顶层 `this` 指向全局对象。
- 函数上下文的词法环境会记录外部作用域引用，是闭包形成的基础。

### 执行栈（Call Stack）
- **结构**：后进先出（LIFO），记录当前所有活动的执行上下文。
- **流程**
  1. 脚本加载时，全局上下文先入栈。
  2. 每次调用函数，创建新的执行上下文并压栈，成为当前活动上下文。
  3. 函数返回后，当前上下文出栈，控制权回到上一个上下文。
- **栈溢出**：递归无出口或调用链太深会触发 `Maximum call stack size exceeded`。

### 例子：栈变化过程
```js
function foo() {
  bar();
}
function bar() {
  console.log("Hi");
}
foo();
```
- 步骤：`Global` 入栈 → 调用 `foo` → `foo` 入栈 → `foo` 调用 `bar` → `bar` 入栈 → `bar` 执行完出栈 → `foo` 出栈 → 栈恢复全局。

### 面试提示
- 强调执行上下文和作用域链、闭包等概念的联系。
- 提及 ES5 中 VO/AO（变量对象/活动对象）与 ES6 词法环境概念的演进。
- 说明执行栈与事件循环协作：同步任务由执行栈完成，异步任务由事件循环调度进入栈内执行。

更多阅读：[执行上下文与执行栈详解](https://vue3js.cn/interview/JavaScript/context_stack.html)
