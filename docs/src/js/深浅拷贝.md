## 深浅拷贝的区别，如何实现一个深拷贝
根本原因是数据类型存储方式导致的，基本数据类型存储在栈中，引用类型对实际对象的引用指针存储在栈中，实际对象内容存储在堆中

- 浅拷贝是拷贝一层，属性是基础类型时，拷贝的是值；属性是引用类型时，拷贝的是对象的引用地址，实际上拷贝前后使用的是堆中同一个对象内容，修改内容会相互影响
- 深拷贝是递归拷贝深层次，属性是引用类型时，会新开辟内存创建存储一个一摸一样的引用对象，拷贝前后使用的不是同一个引用对象，引用地址也不相同，修改内容不会相互影响

### 实现
**浅拷贝**
- Object.assign: `Object.assign({}, { age: 12, nest: { name: 'x' }})`, nest修改会相互影响
- Array.prototype.slice(), Array.prototype.concat()
- 扩展运算符实现的复制
自定义
```js
function shallowClone (obj) {
  if (typeof obj !== 'object' || obj === null) {
    throw new Error('Invalid input')
  }
  const newObj = Array.isArray(obj) ? [] : {}
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = obj[key]
    }
  }
  return newObj
}
```

#### Object.assign vs 扩展运算符
- assign接受一个参数为目标对象，合并源对象到目标对象中。会修改一个对象，触发了setter，返回修改后的对象
- 扩展运算符是拷贝到一个新的数组或者对象中，返回新的对象
- 都不复制继承的属性，会复制Symbol属性

**深拷贝**
- _.cloneDeep()
- JSON.parse(JSON.stringify()): 会忽略Symbol undefined 函数，Date 正则 Map Set WeakMap WeakSet
  - 值为undefined的属性会直接过滤丢失
  - 属性或值为Symbol的属性会直接过滤丢失
  - 值为函数的属性会丢失
  - 值为正则表达式(/[a-z]/ 或 new RegExp())的属性拷贝后为空对象{}
  - Map和Set会处理成空对象{}
  - 值为Date对象的属性转换后会是时间字符串，而不是Date对象
  - 不会拷贝原型链上的属性
手写
```js
// 正则 Date Map等拷贝如果不特殊处理，拷贝后仍然为空对象，因为他们的值类型是对象，但是不是普通对象的形式，没有属性可以枚举，函数是正常的-函数是通过引用传递的，复制的是引用
function cloneDeep (obj) {
  if (typeof obj !== 'object' || obj === null) {
    // throw new Error('Invalid input')
    return obj
  }
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  // Map为示例，一般不需要考虑
  if (obj instanceof Map) return new Map(Array.from(obj, ([key, val]) => [cloneDeep(key), cloneDeep(val)]));

  const newObj = Array.isArray(obj) ? [] : {}
  // Object.keys 自身可枚举，不包括symbol
  // Reflect.ownKeys() 自身all  包括symbol 
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const tmpValue = obj[key]
      if (typeof tmpValue!== 'object' || tmpValue === null) {
        // 简单类型
        newObj[key] = obj[key]
      } else {
        newObj[key] = cloneDeep(tmpValue)
      }
    }
  }
  return newObj
}
```
添加weekMap解决拷贝过程中循环引用(引用自身)和重复拷贝(多次引用同一个对象)的问题
```js
function cloneDeep (obj, hash = new WeakMap()) {
  if (typeof obj !== 'object' || obj === null) return obj
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  
  if (has.has(obj)) return has.get(obj)

  // 类似于 {} [] 新创建一个对象，同上文的newObj
  // 不能直接create(obj)，ob直接作为原型，修改引用类型数据会相互影响
  const cloneObj = Object.create(Object.getPrototypeOf(obj))
  // 防止重复拷贝
  hash.set(obj, cloneObj)

  // 递归拷贝所有自有属性
  for (const key of Reflect.ownKeys(obj)) {
    cloneObj[key] = deepClone(obj[key], hash);
  }
  return cloneObj;
}
```