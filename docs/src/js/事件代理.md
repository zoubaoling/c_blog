## 什么是事件代理，应用场景
> 事件代理也叫事件委托

**原理**
利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定委托到了父元素的身上，在外层元素上执行事件，如果子元素阻止了事件冒泡，那么委托也就不成立

阻止事件冒泡 
  - event.stopPropagation()
  - addEventListener('click',函数名，true/false) 默认是false-事件冒泡，true-事件捕获

**应用场景**
- 大量子元素：当存在一个列表，列表中有大量的列表项，需要点击时响应时间，如果每个列表项一一绑定事件，内存消耗比较大，就可以使用事件委托，绑定在父元素上，执行事件的时候再去匹配
- 动态增删元素：当存在一个列表，列表项不多，但是存在动态增删元素时，如果是一一绑定，在列表变化时，需要去给新增的元素绑定，给删除的元素解绑，如果在外层绑定就不需要这些处理
> 在v-for中绑定事件，内部会优化，最终只会被绑定一次，不会导致事件多次绑定的问题

**优点**

适合事件委托的事件：`click`, `mousedown`, `mouseup`, `keydown`, `keyup`, `keypress`
1. 动态绑定，减少重复工作
2. 减少了事件的绑定，减少了内存的占用，提升了整体性能

**局限性**
- focus blur没有事件冒泡机制，无法委托
- mousemove mouseout这样的事件有冒泡，但是需要不断通过位置计算定位，性能消耗比较高，不适合事件委托
- 不能盲目的所有事件都用委托，可能会出现误判