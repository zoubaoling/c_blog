## Vue 3 性能为什么比 Vue 2 好？

### 1. 编译阶段优化
- **静态提升（Hoist Static）**：编译时把静态节点提到渲染函数外部，只创建一次，复用引用，减少运行期重复创建和 GC 压力。
- **Patch Flag（动态标记）**：编译器标记出真正会变的节点/属性，Diff 时只对有标记的部分做比对，大量静态内容直接跳过。
- **事件缓存**：内联事件处理函数会被缓存，除非依赖的响应式数据变化，否则不会重新生成，降低内存分配成本。
- **Fragment / Block tree**：模板被拆成 Block，Diff 时直接跳到包含动态内容的块，大幅减少遍历范围。

### 2. 响应式系统升级
- **Proxy 替代 `Object.defineProperty`**：无需初始化时递归所有属性，动态新增/删除属性、数组索引都天然支持响应式。
- **懒响应（Lazy proxying）**：只有访问到子对象时才继续代理，避免一次性遍历整个对象树。
- **依赖跟踪更精细**：`effect / track / trigger` 架构使用 `WeakMap → Map → Set` 保存依赖关系，访问粒度更细，调度富有弹性（支持自定义 Scheduler）。

### 3. 体积与 Tree-shaking
- **按需编译**：核心模块拆分，构建时只打包用到的 API（`createApp`、`onMounted` 等），而不是像 Vue 2 把全部内置模块都打包进去。
- **移除冷门 API**：如 `filter`、`$on/$off/$once`、`Vue.set/delete` 等被淘汰，精简核心代码。

### 4. 运行时优化
- **更高效的渲染调度**：结合 `scheduler`、异步队列与 `Promise` 微任务，让多次修改合并成一次更新。
- **自定义渲染器架构**：核心与渲染平台解耦，同一套响应式引擎可应用于 Web、Native、SSR 等场景，便于针对不同平台做优化。
- **SSR 性能提升**：新的 hydration 逻辑、Suspense、异步组件机制让首屏加载更快，支持流式渲染。

### 5. 生态层面的影响
- Bundler（Vite 等）深度适配 Vue 3，利用 ESM 加速开发编译；组合式 API 更易做逻辑拆分与按需加载，从项目层面进一步提升性能。

### 面试答题建议
1. 先按“编译 → 响应式 → 体积”三个维度概述差异。
2. 可举具体示例：静态提升、Patch Flag、Proxy 如何避免 Vue 2 的坑（如 `Vue.set`）。
3. 若被追问，可提运行时调度（scheduler）与 SSR 改进。
4. 结尾点出生态（Vite/Tree-shaking/组合式 API）如何帮助项目性能优化。

这样的结构既说明原理，也展现实践层面的收益。
