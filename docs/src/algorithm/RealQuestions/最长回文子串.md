# 最长回文子串
```
题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```

```
示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

```
示例 2：
输入: "cbbd"
输出: "bb"
```

## 动态规划法
> s[i,j]表示字符串从i到j的字符串片段，由于回文子串的特性，s[i,j]是否为回文子串取决于s[i+1,j-1]

1. s[i+1,j-1]不是回文子串，那么s[i,j]一定不是
2. s[i+1,j-1]是回文子串，那么判断s[i]和s[j]
   1. s[i] === s[j]，s[i+1,j-1]是回文子串
   2. s[i] !== s[j]，s[i+1,j-1]不是回文子串

**最优子结构**： 可以看出字符串是否为回文子串，取决于其是否包含较短的回文子串，此为

**重叠子问题**： 如果按照暴力解决，可能会对同一个字符串重复判断是否为回文子串

**求最值**：求最长的回文子串

综上，满足动态规划的特征

### 实现

**1. dp定义**

由于当前字符串状态不是取决于之前的字符串，而是取决于字符串范围内的子串，所以不能和之前的题目一样dp[i]表示前面的状态

关键点在于`范围`：[i,j]取决于[i-1,j-1], 所以使用一个二维数组`dp[i][j]`索引表示`范围i-j`

**dp[i][j]存储的是什么内容？**

[i,j]根据[i-1,j-1]是否是回文子串来处理，直接设置为布尔值，状态转移更加方便，只需要判断布尔值，设置布尔值，递推关系比较简单；题目所求为最大长度，长度可通过j-i计算

`dp[i][j]表示s中s[i]到s[j]的子字符串是否为回文子串`

**2. 递推公式**
```js
if (s[i] === s[j] && dp[i+1][j-1]) {
    dp[i][j] = true
}
```

**3. 初始化**
   - 长度为1的子串都是回文子串，即`j==i -> dp[i][i] = true`
   - 长度为2的子串，如果两个字符相等，也是回文子串
   - 长度大于2的子串，满足递推公式时就是回文子串(即使是基数，s[i+1]和s[j-1]是同一个字符也满足要求)

**4. 遍历顺序**

`第一层遍历`: 要求最大回文子串的长度，可以遍历`子字符串的长度`;

初始化处理了长度为1和2的dp数据，所以从3开始遍历，递增，遍历结束时对应的就是最大值

`第二层遍历`: 遍历`字符串起始位置i`, 结束位置由当前遍历的字符串当读和起始位置决定；遍历处理字符串中当前固定长度的所有子字符串的状态；

每一个字符串长度对应的`所有子字符串`都要重新`从头开始`遍历数组，从前往后移动，递增

**5. 结果**

获取最大回文子字符串

`最大回文子串的长度`： 遍历结束时，第一层遍历的变量就对应最大回文子串的长度(以最后满足递推公式的情况为准，<= 字符串长度)

`最大回文子串的起始位置`: 遍历结束时，最后一个满足条件的遍历字符串就是最大回文子串，那么它的起始位置(第二层变量)就是最大回文子串的起始位置

**最后根据字符串的长度和起始位置返回对应字符串**

## 中心扩展法-双指针
### 主要思想
确定中心点，从中心点往两边扩散，检查两边字符是否相等，确定最长的回文子串

**中心点**：一个字符(奇数) 和 两个字符(偶数)

### 实现
1. `一层遍历`：遍历中心点，由于字符串最短长度为1，所以中心点范围在`s[0, s.length - 1]`
2. `二层遍历`: 以当前中心点为依据，向两边扩散(循环遍历字符)，记录当前中心点对应的最长回文子串的位置和长度
   - 分别计算一个字符为中心和两个字符为中心的最大回文子串的长度，取最大值
   - 比对旧的最大值，更新最大值和最大子串位置

::: tip 起始位置的计算
A [B C <u>D</u> C B];   A B [C C <u>D</u> D C C] H

`start = i - Math.floor((len - 1) / 2)`: 给的中心`i`或`(i, i+1)`向左扩展了`(len - 1) / 2`个字符(减去中心点本身，偶数位则需要Math.floor)

`end = i + Math.floor(len / 2)`: 给的中心`i`或`(i, i+1)`向右扩展了`len/2`个字符(奇数位需要Math.floor)
:::

::: details 展开查看代码
::: code-group
<<< @/algorithm/RealQuestions/ts/LongestPalindrome.ts
:::