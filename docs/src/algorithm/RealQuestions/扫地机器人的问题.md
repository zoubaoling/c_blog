# 问题机器人的问题
**关键字：DFS**
```
题目描述：房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。
扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。
当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。
请利用提供的4个API编写让机器人清理整个房间的算法
```
```js
interface Robot {
  // 若下一个方格为空，则返回true，并移动至该方格
  // 若下一个方格为障碍物，则返回false，并停留在原地
  boolean move();

  // 在调用turnLeft/turnRight后机器人会停留在原位置
  // 每次转弯90度
  void turnLeft();
  void turnRight();

  // 清理所在方格
  void clean();
}
```
```
示例:
输入:
room = [
[1,1,1,1,1,0,1,1],
[1,1,1,1,1,0,1,1],
[1,0,1,1,1,1,1,1],
[0,0,0,1,0,0,0,0],
[1,1,1,1,1,1,1,1]
],
row = 1,
col = 3
解析: 房间格栅用0或1填充。0表示障碍物，1表示可以通过。 机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右
```
```
注意:
输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用4个给出的API解决问题。 
扫地机器人的初始位置一定是空地。
扫地机器人的初始方向向上。
所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达。
可以假定格栅的四周都被墙包围。
```

## 思路分析
和岛屿数量不一样，岛屿是遍历网格，以当前网格为原点，前后左右递归直到这一块岛屿的边界(0)，再继续遍历以下一个网格为原点开始递归

扫地机器人从原点开始出发，探测前后左右四个方向，某个方向上没有障碍物就前进并递归探测四个方向，遇到`障碍物0`无法前进，只能调转方向回退原点，继续探索剩下的方向

扫地机器人只能以某一个点为原点，前后左右探测，遇到障碍物回退，没有就前进，不断的探测回退跳转方向将网格全部清理完

> 默认机器人在某个原点都是向右旋转方向

1. 初始化机器人方向和清扫标记`set`，以网格原点开始递归
2. 假设初始方向为0，进行递归处理
   1. 如果当前网格坐标已清理，退出; 如果没有则开始清理并将坐标标记为已清除
   2. 遍历四个方向，前进 -> 递归处理完 -> 旋转方向回退 -> 旋转剩下三个方向并递归处理

### 方向处理
1. `探测方向上` 如果方向上-0没有障碍物就前进然后`递归处理-新的中心点`，处理网格
2. 方向旋转180(反向-下)，然后前进，回到原来的中心点
3. 再旋转方向180，回到原来的方向上，探测方向上之前的状态
4. 向右旋转+90
5. `探测方向右` 继续步骤1-4,方向右递归处理完，继续旋转处理下一个方向
6. `探测方向下` 继续步骤1-4,方向下递归处理完，继续旋转处理下一个方向
7. `探测方向左` 继续步骤1-4,方向左递归处理完，当前网格已经递归处理完成

### 方向与坐标
> 不同的方向，前进后的坐标算法不一样，需要记录当前的方向来计算前进坐标，使用[0, 90, 180, 270]来记录四个方向

1. 上: x: i - 1
2. 右: y: j + 1
3. 下: x: i + 1
4. 左: y: j - 1

### 标记记录set
1. 检测前方是否有障碍物是第三方提供的方法，是盲盒，如果修改了原数组的内容，可能会影响判断结果。且机器人如果遇到障碍物需要回退
2. 将坐标处理为字符串存储，而不是用数组，数组是对象类型，每次存储的引用不一样

::: details 展开查看代码
<<< @/algorithm/RealQuestions/ts/RobotCleanRoom.ts
:::