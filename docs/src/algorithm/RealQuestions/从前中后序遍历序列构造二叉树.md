# 二叉树
## 从中序与后序遍历序列构造二叉树
```
题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。
```
```
注意: 你可以假设树中没有重复的元素。
例如，给出
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
```
```
    3
   / \
  9  20
    /  \
   15   7
```
关键字：`二叉树 前序 中序 遍历序列 递归`
> 二叉树类题目存在重复逻辑，大多数都是通过递归完成的

### 思路分析
`中序 inorder`: 左 中 右 -> `[...left] root [...right]`

`后序 postorder`: 左 右 中 -> `[...left, ...right] root`

1. `postorder`的最后一个数据就是当前(子)树的根节点root, 根节点前就是由左子树和右子树混合在一起的数组，左右分隔点不明确
2. 遍历inorder，找到由步骤1得到的root,将数组分隔得到`左中序子树left`和`右中序子树right`
3. 由步骤2可得左子树，根据左子树的长度，将postorder里的数据再分割为`左后序子树left`和`右后序子树right`
4. 构造节点：根节点、左节点、右节点；左节点和右节点就是分别通过`[左中序子树， 左后序子树], [右中序子树，右后序子树]`递归的重复步骤1-3

**由上可总结解题步骤为：**

1. 处理根节点-后序遍历数组的最后一个数据
   - 前序或后序遍历数组长度为0，没有节点，返回`null`
   - 后序遍历数组长度为1，表明只有一个节点为叶子节点，直接构造为根节点并返回
2. 查找中序数组的切割点-根节点的索引，后序数组的最后一个数据为根数据，切割为`[...leftPostorder, ...rightPostorder]和 [root]`
3. 切割中序数组，遍历中序数组，查找`root`以此为分隔点，将数组切割成`[...leftInorder]、[root]、[...rightInorder]`
4. 切割后序数组，通过`leftInorder左中序数组`的长度将后序数组切割成左右数组`[...leftPostorder] 和 [...rightPostOrder]`
5. 递归处理根节点的左节点和右节点: `left(leftPostorder, leftInorder)` 和 `right(rightPostorder, rightInorder)`
   - 左前序数组 和 左后序数组：都表示的是当前节点左子树数据，递归过程再切割处理对应的左子树数据，直到叶子节点(每次递归过程中都可以看作一个单独的子树)
   - 右前序数组 和 右后序数组：都表示的是当前节点右子树数据，递归过程中再接个处理对应的右子树数据，直到叶子节点

## 从前序与中序遍历序列构造二叉树
```
根据一棵树的前序遍历与中序遍历构造二叉树
```
```
注意: 你可以假设树中没有重复的元素
例如，给出
前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：
```
```
    3
   / \
  9  20
    /  \
   15   7
```
与上题`中序和后序构造`类似

`前序`: 中 右 左 -> 第一个元素为根节点
`中序`: 左 中 右

### 解题步骤
1. 当前序或者中序数组长度为0时，为空节点，返回null
2. 当前序数组长度为1时，只有一个节点为根节点，构造节点并返回
3. 查找中序数组的切割点-根节点的索引，根数据为前序数组中的第一个元素 `inorderIndex`
4. 切割中序数组，使用`inorderIndex`将中序数组切割为`[左中序] 和 [右中序]`
5. 切割前序数组，使用`[左中序]`的长度，将前序数组切割为`[左前序] 和 [右前序]`
6. 递归处理根节点的左节点和后节点
   - 左节点：使用`(左前序，左中序)`递归处理当前左子树，根据一对新的前序和中序构造其对应的二叉树/节点
   - 右节点：使用`(右前序，右中序)`递归处理当前左子树

::: details 展开查看代码
<<< @/algorithm/RealQuestions/ts/BuildTreeByTraverseQuence.ts
:::