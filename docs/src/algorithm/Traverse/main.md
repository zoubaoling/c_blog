## 遍历专题
1. `DFS(Depth-First Search)` 深度优先搜索，与栈相关
2. `BFS(Breadth-First Search)` 广度优先搜索，与队列有关

### DFS
DFS可以看作是`不撞南墙不回头`，在前进的路上会遇到岔路口，选择一条路一直走下去，直到无路可走，退回到岔路口，岔路口都走完没路了再退回到上一个岔路口，就是“穷举法”，尽量把所有的路都走一遍

**深度优先搜索的核心思想就是，试图穷举所有的完整路径**

#### 栈结构
岔路口某条路往前走，无路可走时再回头到岔路口，就像栈的后进先出，所以DFS与栈相关

且与二叉树的前序遍历类似(如果存在左子节点，就头也不回的深入访问，直到为空，才退回到最近的父节点，再尝试访问其右子节点)

### BFS
BFS则关心的是当前能够直接达到的所有位置，类似于扫描，观察当前位置的可以直接访问的位置，记录完就继续访问可以直接访问的位置，类似先进先出，即与队列相关

BFS与二叉树的层序遍历类似，按照层次的顺序，从上到下，从左到右的遍历二叉树

## 递归与回溯
### 全排列问题
题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列(拿到一个n个数的数组，穷举出这个数组的所有排列方式)

示例：   
输入: [1,2,3]
输出: [
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]

**穷举**则为深度遍历搜索DFS
1. 深度找完一条路后(找到底), 就出栈，回到上一条岔路口继续递归
2. 重复边界为递归深度与数组长度相等，即当前元素下，数组已遍历完
3. 重复：
   1. 检查剩下的数字有哪些，排出数组中已存在数据，选取一个填进坑里
   2. 递归填充当前元素的坑
   3. 元素出栈，回到上一条岔路口
::: details 展开代码
<<< @/algorithm/Traverse/AllPermute.ts
:::

### 组合问题：变化的坑位，不变的套路(遍历子集)
题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）

说明：解集不能包含重复的子集

示例: 输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]

1. 递归式：检查还剩下哪些数字，选取一个填进坑里，或者空出来
2. 递归边界：当组合里的最大长度为数组长度时则为触碰边(可以小于)
::: details 展开代码
<<< @/algorithm/Traverse/SubPermute.ts
:::

### 限定组合问题：即时回溯，即为”剪枝“
题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]

与上述的排列差别在于限制了组合的长度，当组合长度为k时，即存储退出
::: details 展开代码
<<< @/algorithm/Traverse/CombinePermute.ts
:::

### 回溯思想
> 一条路往前走，能进则进，不能进则退，换一条路事实

DFS就是回溯思想的实践
#### 解题模版
**场景：什么时候用**

1. 暗示有一个或者多个解，需要详尽的列出每一个解的内容，需要考虑DFS、递归回溯
2. 题目经粉丝后，可以转化为树形逻辑模型求解

**依据：为什么这么用**
递归与回溯就是穷举的过程，列出每一个解的内容

> 动态规划不问解的内容而是个数，需要和DFS分开

**步骤：怎么用**
1. 递归式：找坑位，每个坑位就是树中的每一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容
2. 递归边界：题目约束或者默认是坑位数量
::: details 点击展开模版
```
function xxx(入参) {
  前期的变量定义、缓存等准备工作 
  
  // 定义路径栈
  const path = []
  
  // 进入 dfs
  dfs(起点) 
  
  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return   
    }
    
    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```
:::
