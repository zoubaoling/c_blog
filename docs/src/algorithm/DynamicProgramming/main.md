# 动态规划
## 爬楼梯问题
题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶（给定 n 是一个正整数）

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例1:
```md
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1 阶 + 1 阶
2 阶
```
示例2:
```md
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶
```
### 思路分析
关键特征：
1. 要求达成某个目的的**解法个数**
2. 不要求给出每一个解法对应的具体路径

满足以上两个特征往往通过动态规划求解

#### 递归分析
基于“动态规划”做题，首先想到“倒着分析问题”：
1. 定位到问题的终点--走到第`n`阶楼梯这个目标对应的路径数`f(n)`
2. 站在问题的终点这个视角，思考后退的可能性

**步骤**
题目中说明每次只能前进1步或者2步，即也只能后退1步或者2步，故而分析回退可能性：
1. `f(n) = f(n - 1) + f(n - 2)`
2. `f(n - 1) = f(n - 2) + f(n - 3)`;  `f(n - 2) = f(n - 3) + f(n - 4)`
3. ...直到`f(3) = f(2) + f(1)` ->  `f(1) = 1; f(2) = 2`

**递归条件**
1. **重复内容**: `f(n) = f(n - 1) + f(n - 2)`
2. **边界条件**: `f(1) = 1; f(2) = 2`

#### 记忆化搜索提效
**问题** 在上述递归分析中`f(n) = f(n - 1) + f(n - 2)`和`f(n - 1) = f(n - 2) + f(n - 3)`存在重复计算：`f(n - 1) 和 f(n - 2)`; 递归次数越多，重复计算次数越多

**解决** 添加数组缓存，已经计算过的直接取值，避免重复计算

#### 记忆化搜索转动态规划
1. **记忆化搜索**可以理解为优化后递归，`自顶向下`从一个较大的`未知`量级拆分成较小的`已知`量级
2. **动态规划**是一个`自下而上`的过程，通过定位`已知和未知`的关系，向前推导，进而求得`未知`的值--从`f(1)`和`f(2)`为起点，不断求和，循环递增`n`，求`f(n)`的值

::: details 展开查看爬楼梯代码
<<< @/algorithm/DynamicProgramming/ClimbStairs.ts
:::

## 动态规划题解思路
**动态规划**与**分治**类似，只是分治中的各个子问题之间是独立的，比如子数组的排序并不互相影响；而动态规划的各个子问题是`相互依赖、相互影响`的

**动态规划的关键特征：**
1. 要求达成某个目的的**解法个数**
2. 不要求给出每一个解法对应的具体路径

> 看到求最值考虑动态规划

**动态规划的关键组成**：
1. 最优子结构：问题的最优解包含着子问题的最优解，此后的状态基于当前状态-上次决策产生的最优决策；eg: `f(n) = f(n - 1) + f(n - 2)`--又名`状态转移方程`
2. 重叠子问题：在递归的过程中，出现了重复计算的情况

**对于动态规划问题的分析路径**：
1. 通过递归思想明确树形思维模型：找到问题终点，倒退思考的姿势，可以帮忙快速明确`状态间的关系`--递归边界往往是已知子问题的解
2. 结合记忆化搜索(开辟数组存储前面的最优子结果)，明确`状态转移方程`，自下而上，由已知到未知
3. 递归代码转为迭代(状态转移方程转移到循环里)

### “最值”型问题典范：如何优雅地找硬币
题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例1：
```md
输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1
```
示例2：
```md
输入: coins = [2], amount = 3
输出: -1
```
:::tip
**最值问题**是动态规划的常见对口题型
:::

#### 思路分析
**1. 倒退分析确认状态转移**

假设已有amount=36的硬币，不清楚硬币个数，假设硬币为c1, c2, ...cn, 目的为：将amount=36的硬币变为amount=0
- 后退一步，拿走一枚硬币，可能是c1, c2, ...cn
- 那么最小硬币数`f(amount=36) = Math.min(f(36-c1) + 1, f(36-c2) + 1, ...f(36-cn) + 1)`
- 继续倒退再拿走一枚硬币`f(amount=36-c1) = Math.min(f(36-c1-c2) + 1, f(36 - c1 - c3) + 1, ...f(36-c1-cn) + 1)`
- 直到倒退到`f(amount=0) = 0`

**状态转移方程**: `f(amount) = Math.min(f(amount - c1) + 1, f(amount - c2) + 1, ...f(amount-cn) + 1)`

**2. 已知的最基本字问题**
递归后退的边界条件为硬币总额为0的情况：`f[0] = 0`
::: details 展开查看最小硬币组合代码
<<< @/algorithm/DynamicProgramming/FindCoin.ts
:::

## 0-1背包模型
> 有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？

> 注意：每种物品都只有1件