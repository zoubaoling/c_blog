## 队列
`先进先出，后进后出`

### 使用栈实现队列
`栈`是先进后出，`队列`是先进先出，相当于要先将栈底元素出栈，但是被压在最底部，需要将栈倒序，可以再单独维护一个栈存储倒序的数据

栈的栈顶是后入栈的元素，栈底是先入栈的元素

队列的顶部是先入栈的元素，队列底部是后入栈的元素

1. 主栈按顺序存入入队数据，副栈倒序存入主栈数据
2. 当取队列队首数据时，先将主栈栈顶顺序出栈存入到副栈，直至主栈空，那么副栈中就是倒序的
3. 操作副栈就实现了队列的先进先出
::: details 展开代码
<<< @/algorithm/Queue/queueByStack.ts
:::

### 双端队列
`双端队列`就是允许在头部和尾部两端进行插入和删除的队列，编码上就是即允许`pop push`(队列尾部) ,也支持`shift unshift`(队列头部)

### 滑动窗口问题
题目描述：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值

示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]

#### 双指针 + 遍历法
`双指针` 限制范围，使用两个指针标志窗口的开端和尾部
1. 遍历数组
2. 根据左右指针获取窗口数据，遍历窗口获取窗口里的最大值
3. 更新左指针和右指针

#### 双端队列
> 维护一个双端队列存储倒序数据，按顺序添加，队尾比当前元素要大，所以队头就是窗口的最大值

1. 维持队列的递减性，确保对头就是当前滑动窗口的最大值。当当前数据比队尾数据大时，现将队尾出队
2. 当前数据入队
3. 保持队列窗口数据的有效性，若队头对应的索引在窗口之外(当前索引 - 窗口大小)出队
4. 当索引大于等于窗口大小时，将队头即窗口最大值添加进结果列表

::: details 展开代码
<<< @/algorithm/Queue/slidingWindow.ts
:::




