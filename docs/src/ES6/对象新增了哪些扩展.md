## ES6+ 对象新增了哪些常用扩展？

> 建议面试回答：语法糖 → 常用 API → 枚举规则 → 遍历方式 → 其他关键字。

### 1. 对象字面量语法糖
- **属性简写**：键名与变量名一致时可省略 `key: value`。
  ```js
  const name = "Alice";
  const user = { name, greet() { console.log("Hi"); } };
  ```
  *注意：简写的方法不能当作构造函数调用。*
- **可计算属性名**：使用 `[]` 包裹表达式作为键名，可动态生成属性。
  ```js
  const field = "age";
  const obj = { [field]: 18 };
  ```
  表达式若返回对象会被转换为字符串（`[object Object]`）；属性名只能是字符串或 `Symbol`。

### 2. 新增的对象操作 API
- `Object.is(a, b)`：类似 `===`，但能区分 `+0/-0`，并认为 `NaN === NaN`。
- `Object.assign(target, ...sources)`：浅拷贝/合并对象，引用类型值会共享。
- `Object.setPrototypeOf(obj, proto)` / `Object.getPrototypeOf(obj)`：动态读写原型。
- `Object.keys` / `Object.values` / `Object.entries`：遍历自身可枚举属性（不含 `Symbol`）。
- `Object.fromEntries(iterable)`：把键值对数组（或 Map）转回对象，常与 `Object.entries` 配合。
- `Object.getOwnPropertyDescriptors(obj)`：一次性获取所有属性描述符，便于深拷贝 getter/setter。

### 3. 自身属性的枚举顺序
影响 `Object.getOwnPropertyNames`、`Reflect.ownKeys` 等 API 的返回顺序：
1. 所有数值键（含数字字符串）按升序。
2. 字符串键按插入顺序。
3. `Symbol` 键按插入顺序。

### 4. 属性遍历方式对比
| 方法 | 遍历原型链 | 仅枚举属性 | 包含 `Symbol` |
| --- | --- | --- | --- |
| `Object.keys` | 否 | 是 | 否 |
| `for...in` | 是（自身 + 原型） | 是 | 否 |
| `Object.getOwnPropertyNames` | 否 | 否（含不可枚举） | 否 |
| `Object.getOwnPropertySymbols` | 否 | - | 仅 `Symbol` |
| `Reflect.ownKeys` | 否 | 否 | 是（全部） |

> `JSON.stringify`、`for...in` 的枚举顺序依实现而定，但大多遵循上述规则。

### 5. 扩展运算符与剩余参数
- **拷贝/合并**：`const clone = { ...source, role: "admin" };`
- **剩余属性**：`const { id, ...profile } = user;`
- 行为等同 `Object.assign({}, source)`，只拷贝自身可枚举属性，属于浅拷贝。

### 6. `super` 关键字（对象方法中）
- 在对象字面量方法内可以通过 `super` 调用原型上的同名方法。
  ```js
  const base = { greet() { return "hello"; } };
  const obj = {
    greet() {
      return super.greet() + " world";
    }
  };
  Object.setPrototypeOf(obj, base);
  ```

### 面试提示
- `Object.assign` 不会复制原型；引用属性共享需额外处理。
- `Object.is` 与 `===` 的差异是高频追问点。
- 判断属性是否可枚举：`obj.propertyIsEnumerable(key)`。
- `Object.defineProperty` 默认 `enumerable: false`，字面量/`Object.create` 默认可枚举。
- 回答时可按“语法糖 → API → 遍历 → 其他”结构输出，条理清晰。
