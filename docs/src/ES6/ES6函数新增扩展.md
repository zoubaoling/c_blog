## ES6 函数新增了哪些扩展？

> 回答顺序建议：默认参数 → Rest/Spread → name 属性 → `new.target` → 块级函数 → 箭头函数。

### 1. 参数默认值
- 形参可直接写默认值，调用时未传或传 `undefined` 会使用默认值；传 `null` 会按 `null` 处理。
- 设置默认值后，形参与 `arguments` 脱钩（行为类似 ES5 严格模式）。
- 默认值在调用时求值，后面的参数可引用前面参数的值。
- 参数列表形成独立作用域，默认值表达式中无法访问函数体内的变量。

### 2. Rest 参数与展开运算符
- `function sum(...nums) {}`：`...` 收集剩余参数，返回数组；必须位于形参列表末尾，每个函数仅允许一个 Rest。
- Rest 无法用于对象访问器（setter 只能有一个参数）。
- Rest 参数可替代 `arguments`，语义更清晰。
- 展开运算符 `fn(...arr)` 把数组展开成独立实参；函数调用、数组/对象合并中都常用。

### 3. 函数 `name` 属性
- `function foo(){}` → `foo.name === "foo"`。
- 赋值表达式若包含具名函数表达式，以函数名为准，否则退回变量名。
- `Function` 构造器创建的函数 `name` 为 `"anonymous"`。
- 绑定函数 `fn.bind(this)` 的 `name` 前缀为 `"bound "`。

### 4. `new.target`
- 只能在函数或类内部使用，用于判断是否通过 `new` 调用。
- 普通调用：`new.target === undefined`；构造调用：`new.target === 构造函数本身`。
- 常用于限制构造调用、或在父类中判断由哪个子类实例化。

### 5. 块级函数声明
- ES6 允许在块级作用域内定义函数，行为贴近 `let` 声明：仅在块内有效。
- 在非严格模式下各浏览器行为存在差异，推荐配合 `let`/`const` 或函数表达式显式声明。

### 6. 箭头函数
- 语法简洁，`(args) => expression`。
- `this` 取决于定义位置的外层作用域。
- 不能作为构造函数（没有 `[[Construct]]`）；无 `prototype` 属性。
- 不可改变 `this` 指向，`call`/`apply` 仅传参用途。
- 想获取参数列表时需使用 Rest 参数。

### 面试提示
- 易考点：默认参数与 `arguments` 的关系、`new.target` 的使用场景、箭头函数 vs 普通函数差异。
- 回答时按“语法 → 行为差异 → 使用限制”结构，可快速覆盖常见追问。