# TypeScript基本数据类型

## 题目
TypeScript中有哪些基本数据类型？请举例说明。

## 答案

### 1. 基本类型

```typescript
// 数字类型
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;

// 字符串类型
let color: string = "blue";
let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1} years old next month.`;

// 布尔类型
let isDone: boolean = false;

// 数组类型
let list: number[] = [1, 2, 3];
let list2: Array<number> = [1, 2, 3];

// 元组类型
let tuple: [string, number] = ["hello", 10];

// 枚举类型
enum Color {
    Red,
    Green,
    Blue,
}
let c: Color = Color.Green;

// Any类型
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false;

// Void类型
function warnUser(): void {
    console.log("This is my warning message");
}

// Null和Undefined
let u: undefined = undefined;
let n: null = null;

// Never类型
function error(message: string): never {
    throw new Error(message);
}

// Object类型
let obj: object = { name: "张三" };
```

### 2. 类型推断

```typescript
// TypeScript会自动推断类型
let x = 3; // 推断为number
let y = "hello"; // 推断为string
let z = [1, 2, 3]; // 推断为number[]
```

### 3. 联合类型

```typescript
let value: string | number = "hello";
value = 42; // 也可以

// 联合类型数组
let arr: (string | number)[] = ["hello", 1, "world", 2];
```

### 4. 字面量类型

```typescript
let direction: "north" | "south" | "east" | "west" = "north";
let status: 200 | 404 | 500 = 200;
```

### 5. 类型断言

```typescript
let someValue: unknown = "this is a string";
let strLength: number = (someValue as string).length;
// 或者
let strLength2: number = (<string>someValue).length;
```
```

```markdown:docs/src/TypeScript/03-接口Interface.md
# TypeScript接口(Interface)

## 题目
请详细解释TypeScript中的接口概念，包括接口的定义、使用场景和高级特性。

## 答案

### 1. 基本接口定义

```typescript
interface User {
    name: string;
    age: number;
    email?: string; // 可选属性
    readonly id: number; // 只读属性
}

// 使用接口
const user: User = {
    name: "张三",
    age: 25,
    id: 1
};
```

### 2. 函数类型接口

```typescript
// 函数接口
interface SearchFunc {
    (source: string, subString: string): boolean;
}

// 实现接口
const mySearch: SearchFunc = function(source: string, subString: string) {
    const result = source.search(subString);
    return result > -1;
};
```

### 3. 可索引接口

```typescript
// 数组接口
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray = ["Bob", "Fred"];

// 对象接口
interface Dictionary {
    [key: string]: string;
}

let myDict: Dictionary = {
    "name": "张三",
    "city": "北京"
};
```

### 4. 类接口

```typescript
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date): void;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    setTime(d: Date) {
        this.currentTime = d;
    }
}
```

### 5. 接口继承

```typescript
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

interface Circle extends Shape {
    radius: number;
}

// 多重继承
interface ColoredSquare extends Square, Circle {
    borderWidth: number;
}
```

### 6. 混合类型接口

```typescript
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}
```

### 7. 接口合并

```typescript
interface Box {
    height: number;
    width: number;
}

interface Box {
    scale: number;
}

// 等价于
interface Box {
    height: number;
    width: number;
    scale: number;
}
```

### 8. 实际应用场景

```typescript
// API响应接口
interface ApiResponse<T> {
    code: number;
    message: string;
    data: T;
    success: boolean;
}

// 用户数据接口
interface UserData {
    id: number;
    username: string;
    email: string;
    avatar?: string;
    createdAt: Date;
}

// 使用示例
async function fetchUser(id: number): Promise<ApiResponse<UserData>> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
}
```
```

```markdown:docs/src/TypeScript/04-泛型Generics.md
# TypeScript泛型(Generics)

## 题目
什么是TypeScript泛型？请详细解释泛型的概念、使用方法和实际应用场景。

## 答案

### 1. 泛型基本概念

泛型是TypeScript中创建可重用组件的一种方式，它允许我们创建可以处理多种数据类型的函数、类或接口。

### 2. 泛型函数

```typescript
// 基本泛型函数
function identity<T>(arg: T): T {
    return arg;
}

// 使用
let output1 = identity<string>("myString");
let output2 = identity("myString"); // 类型推断

// 泛型函数重载
function processData<T>(data: T[]): T[];
function processData<T>(data: T): T;
function processData<T>(data: T | T[]): T | T[] {
    if (Array.isArray(data)) {
        return data.map(item => item);
    }
    return data;
}
```

### 3. 泛型接口

```typescript
// 基本泛型接口
interface GenericIdentityFn<T> {
    (arg: T): T;
}

// 实现
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;

// 泛型接口约束
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);
    return arg;
}
```

### 4. 泛型类

```typescript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };

// 泛型约束
class BeeKeeper {
    hasMask: boolean = true;
}

class ZooKeeper {
    nametag: string = "Mikle";
}

class Animal {
    numLegs: number = 4;
}

class Bee extends Animal {
    keeper: BeeKeeper = new BeeKeeper();
}

class Lion extends Animal {
    keeper: ZooKeeper = new ZooKeeper();
}

function createInstance<A extends Animal>(c: new () => A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;
createInstance(Bee).keeper.hasMask;
```

### 5. 泛型约束

```typescript
// 使用extends约束泛型
interface Constraint {
    length: number;
}

function getLength<T extends Constraint>(arg: T): number {
    return arg.length;
}

getLength("hello"); // 5
getLength([1, 2, 3]); // 3
// getLength(123); // 错误，number没有length属性

// 多重约束
interface Lengthwise {
    length: number;
}

interface Printable {
    print(): void;
}

function process<T extends Lengthwise & Printable>(arg: T): T {
    console.log(arg.length);
    arg.print();
    return arg;
}
```

### 6. 实际应用场景

```typescript
// 1. 状态管理
interface State<T> {
    data: T | null;
    loading: boolean;
    error: string | null;
}

class Store<T> {
    private state: State<T> = {
        data: null,
        loading: false,
        error: null
    };

    setState(newState: Partial<State<T>>): void {
        this.state = { ...this.state, ...newState };
    }

    getState(): State<T> {
        return this.state;
    }
}

// 2. API请求封装
interface ApiResponse<T> {
    data: T;
    status: number;
    message: string;
}

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
    const response = await fetch(url);
    return response.json();
}

// 使用
interface User {
    id: number;
    name: string;
}

const userData = await fetchData<User>('/api/user/1');

// 3. 缓存系统
class Cache<T> {
    private cache = new Map<string, T>();

    set(key: string, value: T): void {
        this.cache.set(key, value);
    }

    get(key: string): T | undefined {
        return this.cache.get(key);
    }

    has(key: string): boolean {
        return this.cache.has(key);
    }
}

// 4. 事件系统
type EventHandler<T> = (data: T) => void;

class EventEmitter<T> {
    private handlers: Map<string, EventHandler<T>[]> = new Map();

    on(event: string, handler: EventHandler<T>): void {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, []);
        }
        this.handlers.get(event)!.push(handler);
    }

    emit(event: string, data: T): void {
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }
}
```

### 7. 高级泛型技巧

```typescript
// 条件类型
type NonNullable<T> = T extends null | undefined ? never : T;

// 映射类型
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};

type Partial<T> = {
    [P in keyof T]?: T[P];
};

// 工具类型
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```
```

```markdown:docs/src/TypeScript/05-高级类型.md
# TypeScript高级类型

## 题目
请详细解释TypeScript中的高级类型，包括联合类型、交叉类型、条件类型、映射类型等。

## 答案

### 1. 联合类型 (Union Types)

```typescript
// 基本联合类型
type StringOrNumber = string | number;
let value: StringOrNumber = "hello";
value = 42;

// 联合类型数组
type StringOrNumberArray = (string | number)[];
let arr: StringOrNumberArray = ["hello", 1, "world", 2];

// 联合类型函数
function processValue(value: string | number): string {
    if (typeof value === "string") {
        return value.toUpperCase();
    } else {
        return value.toString();
    }
}

// 字面量联合类型
type Direction = "north" | "south" | "east" | "west";
let direction: Direction = "north";

// 联合类型与null/undefined
type StringOrNull = string | null;
let name: StringOrNull = "张三";
name = null;
```

### 2. 交叉类型 (Intersection Types)

```typescript
// 基本交叉类型
interface Person {
    name: string;
    age: number;
}

interface Employee {
    id: number;
    department: string;
}

type PersonEmployee = Person & Employee;

const person: PersonEmployee = {
    name: "张三",
    age: 30,
    id: 1,
    department: "技术部"
};

// 交叉类型与联合类型
type StringOrNumber = string | number;
type NumberOrBoolean = number | boolean;
type Combined = StringOrNumber & NumberOrBoolean; // number

// 函数交叉类型
type FunctionA = (x: number) => string;
type FunctionB = (x: string) => boolean;
type CombinedFunction = FunctionA & FunctionB;
// 等价于: (x: number & string) => string & boolean
```

### 3. 条件类型 (Conditional Types)

```typescript
// 基本条件类型
type NonNullable<T> = T extends null | undefined ? never : T;
type T1 = NonNullable<string | number | null>; // string | number

// 条件类型与infer
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

// 条件类型链
type TypeName<T> = 
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T2 = TypeName<string>; // "string"
type T3 = TypeName<number>; // "number"
type T4 = TypeName<boolean>; // "boolean"

// 分布式条件类型
type ToArray<T> = T extends any ? T[] : never;
type T5 = ToArray<string | number>; // string[] | number[]
```

### 4. 映射类型 (Mapped Types)

```typescript
// 基本映射类型
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};

type Partial<T> = {
    [P in keyof T]?: T[P];
};

type Required<T> = {
    [P in keyof T]-?: T[P];
};

// 使用示例
interface User {
    name: string;
    age: number;
    email?: string;
}

type ReadonlyUser = Readonly<User>;
type PartialUser = Partial<User>;
type RequiredUser = Required<User>;

// 自定义映射类型
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

type Record<K extends keyof any, T> = {
    [P in K]: T;
};

// 使用示例
type UserName = Pick<User, 'name'>;
type UserMap = Record<string, User>;
```

### 5. 模板字面量类型 (Template Literal Types)

```typescript
// 基本模板字面量类型
type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";

type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;

// 字符串操作类型
type Uppercase<S extends string> = S extends string ? Uppercase<S> : never;
type Lowercase<S extends string> = S extends string ? Lowercase<S> : never;
type Capitalize<S extends string> = S extends string ? Capitalize<S> : never;
type Uncapitalize<S extends string> = S extends string ? Uncapitalize<S> : never;

// 实际应用
type EventName<T extends string> = `${Uncapitalize<T>}Changed`;
type T0 = EventName<"foo">; // "fooChanged"

// 多级模板字面量
type PropEventSource<T> = {
    on<K extends string & keyof T>(eventName: `${K}Changed`, callback: (newValue: T[K]) => void): void;
};

declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;

const person = makeWatchedObject({
    firstName: "Saoirse",
    lastName: "Ronan",
    age: 26
});

person.on("firstNameChanged", (newName) => {
    console.log(`new name is ${newName.toUpperCase()}`);
});
```

### 6. 索引访问类型 (Index Access Types)

```typescript
// 基本索引访问
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"]; // number
type I1 = Person["age" | "name"]; // string | number
type I2 = Person[keyof Person]; // string | number | boolean

// 数组索引访问
const MyArray = [
    { name: "Alice", age: 15 },
    { name: "Bob", age: 23 },
    { name: "Eve", age: 38 },
];

type Person2 = typeof MyArray[number]; // { name: string; age: number; }
type Age2 = typeof MyArray[number]["age"]; // number
type key = "age";
type Age3 = typeof MyArray[number][key]; // number
```

### 7. 实际应用场景

```typescript
// 1. API响应类型构建
interface ApiResponse<T> {
    data: T;
    status: number;
    message: string;
}

type ApiError = {
    error: string;
    code: number;
};

type ApiResult<T> = ApiResponse<T> | ApiError;

// 2. 状态管理类型
type LoadingState = {
    state: "loading";
};

type SuccessState<T> = {
    state: "success";
    data: T;
};

type ErrorState = {
    state: "error";
    error: string;
};

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

// 3. 表单验证类型
type ValidationRule<T> = {
    required?: boolean;
    minLength?: number;
    maxLength?: number;
    pattern?: RegExp;
    custom?: (value: T) => boolean;
};

type FormValidation<T> = {
    [K in keyof T]: ValidationRule<T[K]>;
};

// 4. 事件系统类型
type EventMap = {
    click: { x: number; y: number };
    keypress: { key: string };
    submit: { formData: FormData };
};

type EventHandler<T> = (event: T) => void;

type EventHandlers = {
    [K in keyof EventMap]: EventHandler<EventMap[K]>;
};
```
```

```markdown:docs/src/TypeScript/06-装饰器Decorators.md
# TypeScript装饰器(Decorators)

## 题目
请详细解释TypeScript装饰器的概念、类型和使用方法。

## 答案

### 1. 装饰器基本概念

装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 `@expression` 这种形式，expression求值后必须为一个函数。

### 2. 类装饰器

```typescript
// 基本类装饰器
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

// 带参数的类装饰器
function logger(prefix: string) {
    return function (constructor: Function) {
        console.log(`${prefix} - Class ${constructor.name} is being instantiated`);
    };
}

@logger("DEBUG")
class Example {
    constructor() {
        console.log("Example instance created");
    }
}

// 类装饰器工厂
function classDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    };
}

@classDecorator
class Greeter2 {
    property = "property";
    hello: string;
    constructor(m: string) {
        this.hello = m;
    }
}
```

### 3. 方法装饰器

```typescript
// 基本方法装饰器
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${propertyKey} with:`, args);
        const result = originalMethod.apply(this, args);
        console.log(`Result:`, result);
        return result;
    };
    
    return descriptor;
}

class Calculator {
    @log
    add(a: number, b: number): number {
        return a + b;
    }
}

// 带参数的方法装饰器
function validate(min: number, max: number) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        
        descriptor.value = function (...args: any[]) {
            const value = args[0];
            if (value < min || value > max) {
                throw new Error(`Value must be between ${min} and ${max}`);
            }
            return originalMethod.apply(this, args);
        };
        
        return descriptor;
    };
}

class User {
    @validate(0, 120)
    setAge(age: number) {
        this.age = age;
    }
}
```

### 4. 属性装饰器

```typescript
// 基本属性装饰器
function readonly(target: any, propertyKey: string) {
    Object.defineProperty(target, propertyKey, {
        writable: false,
        configurable: false
    });
}

class Example2 {
    @readonly
    name: string = "John";
}

// 属性装饰器工厂
function format(formatString: string) {
    return function (target: any, propertyKey: string) {
        let value = target[propertyKey];
        
        const getter = function() {
            return value;
        };
        
        const setter = function(newVal: string) {
            value = formatString.replace('{value}', newVal);
        };
        
        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true
        });
    };
}

class Message {
    @format("Hello, {value}!")
    greeting: string = "World";
}
```

### 5. 参数装饰器

```typescript
// 基本参数装饰器
function parameterDecorator(target: any, propertyKey: string, parameterIndex: number) {
    console.log(`Parameter ${parameterIndex} of method ${propertyKey} is decorated`);
}

class Example3 {
    method(@parameterDecorator param1: string, @parameterDecorator param2: number) {
        // method body
    }
}

// 参数验证装饰器
function validateParameter(target: any, propertyKey: string, parameterIndex: number) {
    const originalMethod = target[propertyKey];
    
    target[propertyKey] = function (...args: any[]) {
        const param = args[parameterIndex];
        if (param === undefined || param === null) {
            throw new Error(`Parameter ${parameterIndex} is required`);
        }
        return originalMethod.apply(this, args);
    };
}

class Example4 {
    method(@validateParameter name: string, @validateParameter age: number) {
        console.log(`Name: ${name}, Age: ${age}`);
    }
}
```

### 6. 装饰器组合

```typescript
// 多个装饰器
function first() {
    console.log("first(): factory evaluated");
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("first(): called");
    };
}

function second() {
    console.log("second(): factory evaluated");
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("second(): called");
    };
}

class Example5 {
    @first()
    @second()
    method() {}
}

// 执行顺序：从下到上，从右到左
// 输出：
// second(): factory evaluated
// first(): factory evaluated
// first(): called
// second(): called
```

### 7. 实际应用场景

```typescript
// 1. 缓存装饰器
function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cacheMap = new Map();
    
    descriptor.value = function (...args: any[]) {
        const key = JSON.stringify(args);
        if (cacheMap.has(key)) {
            return cacheMap.get(key);
        }
        const result = originalMethod.apply(this, args);
        cacheMap.set(key, result);
        return result;
    };
    
    return descriptor;
}

class DataService {
    @cache
    async fetchUser(id: number) {
        // 模拟API调用
        return { id, name: `User ${id}` };
    }
}

// 2. 性能监控装饰器
function measure(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
        const start = performance.now();
        const result = originalMethod.apply(this, args);
        const end = performance.now();
        console.log(`${propertyKey} took ${end - start} milliseconds`);
        return result;
    };
    
    return descriptor;
}

class PerformanceTest {
    @measure
    expensiveOperation() {
        // 模拟耗时操作
        for (let i = 0; i < 1000000; i++) {
            Math.random();
        }
    }
}

// 3. 权限控制装饰器
function requireRole(role: string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        
        descriptor.value = function (...args: any[]) {
            const userRole = this.currentUser?.role;
            if (userRole !== role) {
                throw new Error(`Access denied. Required role: ${role}`);
            }
            return originalMethod.apply(this, args);
        };
        
        return descriptor;
    };
}

class AdminService {
    @requireRole('admin')
    deleteUser(userId: number) {
        console.log(`Deleting user ${userId}`);
    }
}
```

### 8. 装饰器元数据

```typescript
// 需要启用 emitDecoratorMetadata 选项
import "reflect-metadata";

function type(type: any) {
    return Reflect.metadata("design:type", type);
}

function paramTypes(...types: any[]) {
    return Reflect.metadata("design:paramtypes", types);
}

function returnType(type: any) {
    return Reflect.metadata("design:returntype", type);
}

class Example6 {
    @type(String)
    @paramTypes(String, Number)
    @returnType(String)
    method(name: string, age: number): string {
        return `Name: ${name}, Age: ${age}`;
    }
}
```
```

```markdown:docs/src/TypeScript/07-模块和命名空间.md
# TypeScript模块和命名空间

## 题目
请详细解释TypeScript中的模块系统和命名空间，包括它们的区别、使用方法和最佳实践。

## 答案

### 1. 模块系统 (Modules)

#### 1.1 基本模块语法

```typescript
// math.ts - 导出模块
export const PI = 3.14159;

export function add(a: number, b: number): number {
    return a + b;
}

export function subtract(a: number, b: number): number {
    return a - b;
}

// 默认导出
export default class Calculator {
    add(a: number, b: number): number {
        return a + b;
    }
}

// 重新导出
export { Calculator as Calc } from './calculator';
```

#### 1.2 导入模块

```typescript
// main.ts - 导入模块
import { add, subtract, PI } from './math';
import Calculator, { add as addFunction } from './math';

// 命名空间导入
import * as MathUtils from './math';

// 动态导入
async function loadModule() {
    const math = await import('./math');
    console.log(math.add(1, 2));
}
```

#### 1.3 模块类型声明

```typescript
// types.d.ts
declare module 'my-module' {
    export interface User {
        id: number;
        name: string;
    }
    
    export function getUser(id: number): Promise<User>;
}

// 使用
import { User, getUser } from 'my-module';
```

### 2. 命名空间 (Namespaces)

#### 2.1 基本命名空间

```typescript
namespace Validation {
    export interface StringValidator {
        isValid(s: string): boolean;
    }
    
    export class EmailValidator implements StringValidator {
        isValid(s: string): boolean {
            return s.indexOf('@') !== -1;
        }
    }
    
    export class ZipCodeValidator implements StringValidator {
        isValid(s: string): boolean {
            return s.length === 5 && parseInt(s).toString() === s;
        }
    }
}

// 使用命名空间
let emailValidator = new Validation.EmailValidator();
let zipCodeValidator = new Validation.ZipCodeValidator();
```

#### 2.2 嵌套命名空间

```typescript
namespace Geometry {
    export namespace Shapes {
        export class Rectangle {
            constructor(public width: number, public height: number) {}
            
            area(): number {
                return this.width * this.height;
            }
        }
        
        export class Circle {
            constructor(public radius: number) {}
            
            area(): number {
                return Math.PI * this.radius * this.radius;
            }
        }
    }
    
    export namespace Utils {
        export function calculateArea(shape: any): number {
            return shape.area();
        }
    }
}

// 使用
let rect = new Geometry.Shapes.Rectangle(5, 10);
let area = Geometry.Utils.calculateArea(rect);
```

#### 2.3 命名空间别名

```typescript
namespace Shapes {
    export namespace Polygons {
        export class Triangle {}
        export class Square {}
    }
}

import polygons = Shapes.Polygons;
let sq = new polygons.Square();
```

### 3. 模块 vs 命名空间

#### 3.1 模块的优势

```typescript
// 更好的树摇优化
// math.ts
export const PI = 3.14159;
export function add(a: number, b: number): number {
    return a + b;
}

// main.ts - 只导入需要的部分
import { add } from './math';
// PI 不会被包含在最终打包中
```

#### 3.2 命名空间的限制

```typescript
// 全局污染
namespace Utils {
    export function helper() {}
}

// 在全局作用域中，Utils 是可访问的
// 可能导致命名冲突
```

### 4. 实际应用场景

#### 4.1 模块化项目结构

```typescript
// src/
// ├── components/
// │   ├── Button/
// │   │   ├── index.ts
// │   │   ├── Button.tsx
// │   │   └── Button.test.ts
// │   └── Modal/
// │       ├── index.ts
// │       ├── Modal.tsx
// │       └── Modal.test.ts
// ├── services/
// │   ├── api.ts
// │   └── auth.ts
// ├── utils/
// │   ├── validation.ts
// │   └── helpers.ts
// └── types/
//     └── index.ts

// components/Button/index.ts
export { default as Button } from './Button';
export type { ButtonProps } from './Button';

// services/api.ts
export interface ApiResponse<T> {
    data: T;
    status: number;
}

export class ApiService {
    static async get<T>(url: string): Promise<ApiResponse<T>> {
        const response = await fetch(url);
        return response.json();
    }
}

// types/index.ts
export interface User {
    id: number;
    name: string;
    email: string;
}

export interface Post {
    id: number;
    title: string;
    content: string;
    authorId: number;
}
```

#### 4.2 库开发

```typescript
// 库的入口文件
export { default as Button } from './components/Button';
export { default as Modal } from './components/Modal';
export { ApiService } from './services/ApiService';
export type { User, Post } from './types';

// 子模块导出
export * as Utils from './utils';
export * as Constants from './constants';
```

### 5. 高级模块特性

#### 5.1 模块解析

```typescript
// tsconfig.json
{
    "compilerOptions": {
        "moduleResolution": "node",
        "baseUrl": "./src",
        "paths": {
            "@/*": ["*"],
            "@components/*": ["components/*"],
            "@services/*": ["services/*"]
        }
    }
}

// 使用路径映射
import { Button } from '@components/Button';
import { ApiService } from '@services/api';
```

#### 5.2 循环依赖处理

```typescript
// moduleA.ts
import { funcB } from './moduleB';

export function funcA() {
    return funcB();
}

// moduleB.ts
import { funcA } from './moduleA';

export function funcB() {
    return funcA();
}

// 解决方案：使用接口
// types.ts
export interface ModuleA {
    funcA(): string;
}

export interface ModuleB {
    funcB(): string;
}

// moduleA.ts
import { ModuleB } from './types';

export function funcA(dep: ModuleB) {
    return dep.funcB();
}

// moduleB.ts
import { ModuleA } from './types';

export function funcB(dep: ModuleA) {
    return dep.funcA();
}
```

### 6. 最佳实践

#### 6.1 模块组织

```typescript
// 1. 使用明确的导入/导出
// 好的做法
export { Button, ButtonProps } from './Button';
export { Modal, ModalProps } from './Modal';

// 2. 避免默认导出
// 好的做法
export class UserService {
    // ...
}

// 3. 使用index文件统一导出
// components/index.ts
export * from './Button';
export * from './Modal';
export * from './Input';

// 4. 类型和实现分离
// types.ts
export interface User {
    id: number;
    name: string;
}

// userService.ts
import { User } from './types';

export class UserService {
    getUser(id: number): Promise<User> {
        // 实现
    }
}
```

#### 6.2 性能优化

```typescript
// 1. 懒加载
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 2. 动态导入
async function loadFeature() {
    const { FeatureModule } = await import('./feature');
    return new FeatureModule();
}

// 3. 条件导入
let validator: any;
if (process.env.NODE_ENV === 'development') {
    validator = require('./devValidator');
} else {
    validator = require('./prodValidator');
}
```
```

```markdown:docs/src/TypeScript/08-类型推断和类型断言.md
# TypeScript类型推断和类型断言

## 题目
请详细解释TypeScript中的类型推断机制和类型断言的使用方法。

## 答案

### 1. 类型推断 (Type Inference)

#### 1.1 基本类型推断

```typescript
// 变量类型推断
let x = 3; // 推断为 number
let y = "hello"; // 推断为 string
let z = [1, 2, 3]; // 推断为 number[]
let w = [1, "hello"]; // 推断为 (string | number)[]

// 函数返回类型推断
function add(a: number, b: number) {
    return a + b; // 推断返回类型为 number
}

function processArray(arr: number[]) {
    return arr.map(x => x * 2); // 推断返回类型为 number[]
}

// 对象类型推断
const user = {
    name: "张三",
    age: 25,
    email: "zhangsan@example.com"
}; // 推断为 { name: string; age: number; email: string; }
```

#### 1.2 上下文类型推断

```typescript
// 函数参数类型推断
const names = ["Alice", "Bob", "Charlie"];
names.forEach(name => {
    console.log(name.toUpperCase()); // name 推断为 string
});

// 回调函数类型推断
function processCallback(callback: (value: number) => string) {
    return callback(42);
}

processCallback(value => {
    return value.toString(); // value 推断为 number
});

// 数组方法类型推断
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2); // n 推断为 number
const filtered = numbers.filter(n => n > 2); // n 推断为 number
```

#### 1.3 最佳公共类型推断

```typescript
// 联合类型推断
let arr = [0, 1, null]; // 推断为 (number | null)[]

// 上下文中的类型推断
let x: (string | number)[] = ["hello", 1, "world"];

// 泛型类型推断
function identity<T>(arg: T): T {
    return arg;
}

let output1 = identity("myString"); // 推断 T 为 string
let output2 = identity(42); // 推断 T 为 number
```

### 2. 类型断言 (Type Assertions)

#### 2.1 基本类型断言

```typescript
// as 语法
let someValue: unknown = "this is a string";
let strLength: number = (someValue as string).length;

// 尖括号语法
let someValue2: unknown = "this is a string";
let strLength2: number = (<string>someValue2).length;

// 注意：尖括号语法在JSX中不可用
```

#### 2.2 类型断言的使用场景

```typescript
// 1. 处理 any 类型
let value: any = "hello world";
let length: number = (value as string).length;

// 2. 处理联合类型
function processValue(value: string | number) {
    if (typeof value === "string") {
        return (value as string).toUpperCase();
    } else {
        return (value as number).toFixed(2);
    }
}

// 3. 处理 DOM 元素
const canvas = document.getElementById("myCanvas") as HTMLCanvasElement;
const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;

// 4. 处理 API 响应
interface ApiResponse {
    data: any;
    status: number;
}

async function fetchData(): Promise<ApiResponse> {
    const response = await fetch("/api/data");
    return response.json() as Promise<ApiResponse>;
}
```

#### 2.3 类型断言的安全性

```typescript
// 不安全的断言
let value: unknown = "hello";
let length: number = (value as number).toFixed(2); // 运行时错误

// 安全的断言 - 使用类型守卫
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function processValue(value: unknown) {
    if (isString(value)) {
        return value.toUpperCase(); // 安全，TypeScript知道value是string
    }
    return "unknown";
}

// 双重断言
let value: unknown = "hello";
let length: number = (value as unknown as number).toFixed(2); // 不推荐
```

### 3. 类型守卫 (Type Guards)

#### 3.1 基本类型守卫

```typescript
// typeof 类型守卫
function processValue(value: string | number) {
    if (typeof value === "string") {
        return value.toUpperCase();
    } else {
        return value.toFixed(2);
    }
}

// instanceof 类型守卫
class Dog {
    bark() {
        return "woof";
    }
}

class Cat {
    meow() {
        return "meow";
    }
}

function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        return animal.bark();
    } else {
        return animal.meow();
    }
}

// in 操作符类型守卫
interface Bird {
    fly(): void;
    layEggs(): void;
}

interface Fish {
    swim(): void;
    layEggs(): void;
}

function move(animal: Bird | Fish) {
    if ("fly" in animal) {
        return animal.fly();
    } else {
        return animal.swim();
    }
}
```

#### 3.2 自定义类型守卫

```typescript
// 函数类型守卫
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function isNumber(value: unknown): value is number {
    return typeof value === "number" && !isNaN(value);
}

function isArray(value: unknown): value is any[] {
    return Array.isArray(value);
}

// 使用自定义类型守卫
function processData(data: unknown) {
    if (isString(data)) {
        return data.toUpperCase();
    } else if (isNumber(data)) {
        return data.toFixed(2);
    } else if (isArray(data)) {
        return data.length;
    }
    return "unknown";
}

// 对象类型守卫
interface User {
    id: number;
    name: string;
    email: string;
}

function isUser(obj: unknown): obj is User {
    return (
        typeof obj === "object" &&
        obj !== null &&
        "id" in obj &&
        "name" in obj &&
        "email" in obj &&
        typeof (obj as User).id === "number" &&
        typeof (obj as User).name === "string" &&
        typeof (obj as User).email === "string"
    );
}

// 使用对象类型守卫
function processUser(data: unknown) {
    if (isUser(data)) {
        return `User: ${data.name} (${data.email})`;
    }
    return "Invalid user data";
}
```

### 4. 高级类型推断

#### 4.1 条件类型推断

```typescript
// infer 关键字
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

type T1 = ReturnType<() => string>; // string
type T2 = ReturnType<(x: number) => number>; // number

// 参数类型推断
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

type T3 = Parameters<(x: number
