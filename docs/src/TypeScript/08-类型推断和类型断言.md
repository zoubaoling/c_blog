# TypeScript类型推断和类型断言

## 题目
请详细解释TypeScript中的类型推断机制和类型断言的使用方法。

## 答案

### 1. 类型推断 (Type Inference)

#### 1.1 基本类型推断

```typescript
// 变量类型推断
let x = 3; // 推断为 number
let y = "hello"; // 推断为 string
let z = [1, 2, 3]; // 推断为 number[]
let w = [1, "hello"]; // 推断为 (string | number)[]

// 函数返回类型推断
function add(a: number, b: number) {
    return a + b; // 推断返回类型为 number
}

function processArray(arr: number[]) {
    return arr.map(x => x * 2); // 推断返回类型为 number[]
}

// 对象类型推断
const user = {
    name: "张三",
    age: 25,
    email: "zhangsan@example.com"
}; // 推断为 { name: string; age: number; email: string; }
```

#### 1.2 上下文类型推断

```typescript
// 函数参数类型推断
const names = ["Alice", "Bob", "Charlie"];
names.forEach(name => {
    console.log(name.toUpperCase()); // name 推断为 string
});

// 回调函数类型推断
function processCallback(callback: (value: number) => string) {
    return callback(42);
}

processCallback(value => {
    return value.toString(); // value 推断为 number
});

// 数组方法类型推断
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2); // n 推断为 number
const filtered = numbers.filter(n => n > 2); // n 推断为 number
```

#### 1.3 最佳公共类型推断

```typescript
// 联合类型推断
let arr = [0, 1, null]; // 推断为 (number | null)[]

// 上下文中的类型推断
let x: (string | number)[] = ["hello", 1, "world"];

// 泛型类型推断
function identity<T>(arg: T): T {
    return arg;
}

let output1 = identity("myString"); // 推断 T 为 string
let output2 = identity(42); // 推断 T 为 number
```

### 2. 类型断言 (Type Assertions)

#### 2.1 基本类型断言

```typescript
// as 语法
let someValue: unknown = "this is a string";
let strLength: number = (someValue as string).length;

// 尖括号语法
let someValue2: unknown = "this is a string";
let strLength2: number = (<string>someValue2).length;

// 注意：尖括号语法在JSX中不可用
```

#### 2.2 类型断言的使用场景

```typescript
// 1. 处理 any 类型
let value: any = "hello world";
let length: number = (value as string).length;

// 2. 处理联合类型
function processValue(value: string | number) {
    if (typeof value === "string") {
        return (value as string).toUpperCase();
    } else {
        return (value as number).toFixed(2);
    }
}

// 3. 处理 DOM 元素
const canvas = document.getElementById("myCanvas") as HTMLCanvasElement;
const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;

// 4. 处理 API 响应
interface ApiResponse {
    data: any;
    status: number;
}

async function fetchData(): Promise<ApiResponse> {
    const response = await fetch("/api/data");
    return response.json() as Promise<ApiResponse>;
}
```

#### 2.3 类型断言的安全性

```typescript
// 不安全的断言
let value: unknown = "hello";
let length: number = (value as number).toFixed(2); // 运行时错误

// 安全的断言 - 使用类型守卫
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function processValue(value: unknown) {
    if (isString(value)) {
        return value.toUpperCase(); // 安全，TypeScript知道value是string
    }
    return "unknown";
}

// 双重断言
let value: unknown = "hello";
let length: number = (value as unknown as number).toFixed(2); // 不推荐
```

### 3. 类型守卫 (Type Guards)

#### 3.1 基本类型守卫

```typescript
// typeof 类型守卫
function processValue(value: string | number) {
    if (typeof value === "string") {
        return value.toUpperCase();
    } else {
        return value.toFixed(2);
    }
}

// instanceof 类型守卫
class Dog {
    bark() {
        return "woof";
    }
}

class Cat {
    meow() {
        return "meow";
    }
}

function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        return animal.bark();
    } else {
        return animal.meow();
    }
}

// in 操作符类型守卫
interface Bird {
    fly(): void;
    layEggs(): void;
}

interface Fish {
    swim(): void;
    layEggs(): void;
}

function move(animal: Bird | Fish) {
    if ("fly" in animal) {
        return animal.fly();
    } else {
        return animal.swim();
    }
}
```

#### 3.2 自定义类型守卫

```typescript
// 函数类型守卫
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function isNumber(value: unknown): value is number {
    return typeof value === "number" && !isNaN(value);
}

function isArray(value: unknown): value is any[] {
    return Array.isArray(value);
}

// 使用自定义类型守卫
function processData(data: unknown) {
    if (isString(data)) {
        return data.toUpperCase();
    } else if (isNumber(data)) {
        return data.toFixed(2);
    } else if (isArray(data)) {
        return data.length;
    }
    return "unknown";
}

// 对象类型守卫
interface User {
    id: number;
    name: string;
    email: string;
}

function isUser(obj: unknown): obj is User {
    return (
        typeof obj === "object" &&
        obj !== null &&
        "id" in obj &&
        "name" in obj &&
        "email" in obj &&
        typeof (obj as User).id === "number" &&
        typeof (obj as User).name === "string" &&
        typeof (obj as User).email === "string"
    );
}

// 使用对象类型守卫
function processUser(data: unknown) {
    if (isUser(data)) {
        return `User: ${data.name} (${data.email})`;
    }
    return "Invalid user data";
}
```

### 4. 高级类型推断

#### 4.1 条件类型推断

```typescript
// infer 关键字
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

type T1 = ReturnType<() => string>; // string
type T2 = ReturnType<(x: number) => number>; // number

// 参数类型推断
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

type T3 = Parameters<(x: number
