# TypeScript模块和命名空间

## 题目
请详细解释TypeScript中的模块系统和命名空间，包括它们的区别、使用方法和最佳实践。

## 答案

### 1. 模块系统 (Modules)

#### 1.1 基本模块语法

```typescript
// math.ts - 导出模块
export const PI = 3.14159;

export function add(a: number, b: number): number {
    return a + b;
}

export function subtract(a: number, b: number): number {
    return a - b;
}

// 默认导出
export default class Calculator {
    add(a: number, b: number): number {
        return a + b;
    }
}

// 重新导出
export { Calculator as Calc } from './calculator';
```

#### 1.2 导入模块

```typescript
// main.ts - 导入模块
import { add, subtract, PI } from './math';
import Calculator, { add as addFunction } from './math';

// 命名空间导入
import * as MathUtils from './math';

// 动态导入
async function loadModule() {
    const math = await import('./math');
    console.log(math.add(1, 2));
}
```

#### 1.3 模块类型声明

```typescript
// types.d.ts
declare module 'my-module' {
    export interface User {
        id: number;
        name: string;
    }
    
    export function getUser(id: number): Promise<User>;
}

// 使用
import { User, getUser } from 'my-module';
```

### 2. 命名空间 (Namespaces)

#### 2.1 基本命名空间

```typescript
namespace Validation {
    export interface StringValidator {
        isValid(s: string): boolean;
    }
    
    export class EmailValidator implements StringValidator {
        isValid(s: string): boolean {
            return s.indexOf('@') !== -1;
        }
    }
    
    export class ZipCodeValidator implements StringValidator {
        isValid(s: string): boolean {
            return s.length === 5 && parseInt(s).toString() === s;
        }
    }
}

// 使用命名空间
let emailValidator = new Validation.EmailValidator();
let zipCodeValidator = new Validation.ZipCodeValidator();
```

#### 2.2 嵌套命名空间

```typescript
namespace Geometry {
    export namespace Shapes {
        export class Rectangle {
            constructor(public width: number, public height: number) {}
            
            area(): number {
                return this.width * this.height;
            }
        }
        
        export class Circle {
            constructor(public radius: number) {}
            
            area(): number {
                return Math.PI * this.radius * this.radius;
            }
        }
    }
    
    export namespace Utils {
        export function calculateArea(shape: any): number {
            return shape.area();
        }
    }
}

// 使用
let rect = new Geometry.Shapes.Rectangle(5, 10);
let area = Geometry.Utils.calculateArea(rect);
```

#### 2.3 命名空间别名

```typescript
namespace Shapes {
    export namespace Polygons {
        export class Triangle {}
        export class Square {}
    }
}

import polygons = Shapes.Polygons;
let sq = new polygons.Square();
```

### 3. 模块 vs 命名空间

#### 3.1 模块的优势

```typescript
// 更好的树摇优化
// math.ts
export const PI = 3.14159;
export function add(a: number, b: number): number {
    return a + b;
}

// main.ts - 只导入需要的部分
import { add } from './math';
// PI 不会被包含在最终打包中
```

#### 3.2 命名空间的限制

```typescript
// 全局污染
namespace Utils {
    export function helper() {}
}

// 在全局作用域中，Utils 是可访问的
// 可能导致命名冲突
```

### 4. 实际应用场景

#### 4.1 模块化项目结构

```typescript
// src/
// ├── components/
// │   ├── Button/
// │   │   ├── index.ts
// │   │   ├── Button.tsx
// │   │   └── Button.test.ts
// │   └── Modal/
// │       ├── index.ts
// │       ├── Modal.tsx
// │       └── Modal.test.ts
// ├── services/
// │   ├── api.ts
// │   └── auth.ts
// ├── utils/
// │   ├── validation.ts
// │   └── helpers.ts
// └── types/
//     └── index.ts

// components/Button/index.ts
export { default as Button } from './Button';
export type { ButtonProps } from './Button';

// services/api.ts
export interface ApiResponse<T> {
    data: T;
    status: number;
}

export class ApiService {
    static async get<T>(url: string): Promise<ApiResponse<T>> {
        const response = await fetch(url);
        return response.json();
    }
}

// types/index.ts
export interface User {
    id: number;
    name: string;
    email: string;
}

export interface Post {
    id: number;
    title: string;
    content: string;
    authorId: number;
}
```

#### 4.2 库开发

```typescript
// 库的入口文件
export { default as Button } from './components/Button';
export { default as Modal } from './components/Modal';
export { ApiService } from './services/ApiService';
export type { User, Post } from './types';

// 子模块导出
export * as Utils from './utils';
export * as Constants from './constants';
```

### 5. 高级模块特性

#### 5.1 模块解析

```typescript
// tsconfig.json
{
    "compilerOptions": {
        "moduleResolution": "node",
        "baseUrl": "./src",
        "paths": {
            "@/*": ["*"],
            "@components/*": ["components/*"],
            "@services/*": ["services/*"]
        }
    }
}

// 使用路径映射
import { Button } from '@components/Button';
import { ApiService } from '@services/api';
```

#### 5.2 循环依赖处理

```typescript
// moduleA.ts
import { funcB } from './moduleB';

export function funcA() {
    return funcB();
}

// moduleB.ts
import { funcA } from './moduleA';

export function funcB() {
    return funcA();
}

// 解决方案：使用接口
// types.ts
export interface ModuleA {
    funcA(): string;
}

export interface ModuleB {
    funcB(): string;
}

// moduleA.ts
import { ModuleB } from './types';

export function funcA(dep: ModuleB) {
    return dep.funcB();
}

// moduleB.ts
import { ModuleA } from './types';

export function funcB(dep: ModuleA) {
    return dep.funcA();
}
```

### 6. 最佳实践

#### 6.1 模块组织

```typescript
// 1. 使用明确的导入/导出
// 好的做法
export { Button, ButtonProps } from './Button';
export { Modal, ModalProps } from './Modal';

// 2. 避免默认导出
// 好的做法
export class UserService {
    // ...
}

// 3. 使用index文件统一导出
// components/index.ts
export * from './Button';
export * from './Modal';
export * from './Input';

// 4. 类型和实现分离
// types.ts
export interface User {
    id: number;
    name: string;
}

// userService.ts
import { User } from './types';

export class UserService {
    getUser(id: number): Promise<User> {
        // 实现
    }
}
```

#### 6.2 性能优化

```typescript
// 1. 懒加载
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 2. 动态导入
async function loadFeature() {
    const { FeatureModule } = await import('./feature');
    return new FeatureModule();
}

// 3. 条件导入
let validator: any;
if (process.env.NODE_ENV === 'development') {
    validator = require('./devValidator');
} else {
    validator = require('./prodValidator');
}
```
