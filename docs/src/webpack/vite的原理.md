## Vite 原理速记

> 核心思想：开发阶段利用浏览器原生 ES Modules + 按需编译，生产阶段交给 Rollup 打包。

### 开发环境的工作方式
- **即时启动**：直接启动开发服务器，不需要预先打包或构建依赖图，冷启动极快。
- **按需编译**：浏览器请求某个模块时，Vite 才使用对应的处理器（esbuild、插件）编译该模块并返回。
- **HMR**：基于原生 ESM + WebSocket，只重新编译/推送发生变化的模块，细粒度更新。
- **依赖处理**：使用 esbuild（Go 编写，极快）预构建第三方依赖，转换 CommonJS/UMD → ESM，并合并大量内部模块减少请求数。

### 生产环境策略
- **Rollup 打包**：Vite 内置 Rollup 作为生产打包器，依靠其成熟的 Tree-shaking、输出格式、插件生态。
- **配置共享**：Vite 的插件 API 与 Rollup 兼容，可共享大量插件和配置项。

### 核心原理概览
1. **ES Modules 运行时**：利用浏览器识别 `import`，无需提前打包；只要输出合法的模块即可。
2. **预构建缓存**：
   - HTTP 层：依赖使用 `cache-control: max-age=...` 强缓存，源码使用协商缓存（304）；
   - 文件层：预构建结果缓存到 `node_modules/.vite`，相关配置变动时才重新构建。
3. **实时转换**：收到请求时根据文件类型选择处理器：
   - js/ts → esbuild 转换；
   - `.vue` → `@vue/compiler-sfc`；
   - `.jsx/.tsx` → SWC 或 Babel（由插件决定）。
4. **虚拟模块返回**：编译后的模块封装为可执行的 ESM，响应给浏览器。

### 与 Webpack 的区别（开发阶段）
- Webpack：先构建整个依赖图 → 打包产出 bundle → 再由 devServer 提供；修改时可能需要重新打包相关依赖。
- Vite：由浏览器拉取模块，Vite 只需在请求到时编译该模块；修改时只重新处理改动文件，HMR 速度更快。

### 优势与不足
**优势**
- 冷启动、热更新速度显著领先；
- 配置开箱即用，内置 PostCSS、TS 支持；
- 插件开发基于 Rollup API，更简洁；
- 支持 SSR、TS、React/Vue 等多框架。

**不足**
- 开发与生产使用的工具不同（esbuild vs Rollup），调试时需注意差异；
- 非 Vue 项目需要额外官配插件（如 React）；
- 某些依赖（动态 require、Node 内置模块）需要手动预构建或 Polyfill。

### 构建流程（开发态）
1. 运行 `vite` → 启动 dev server。
2. 浏览器请求入口文件 → Vite 解析 import，递归请求依赖。
3. 模块首次请求：按类型即时编译成 ESM 模块。
4. 浏览器执行返回的模块；若文件更新，Vite 通过 HMR 推送更新模块。

掌握以上要点，可从“开发原理 → 生产策略 → 与 Webpack 对比 → 优缺点”层面回应面试中的 Vite 原理问题。